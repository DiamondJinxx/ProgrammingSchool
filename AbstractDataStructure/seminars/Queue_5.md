# Очереди
Очереди потому и называются очереди, что они работают как очереди: вход (добавление) происходит в хвост очереди, а выход (удаление) -- из её головы.

FIFO, first-in first-out -- первым пришёл, первым вышел
Очередь очевидно моделируется либо стандартным списком Python, либо изученным ранее связанным списком, так как мы можем добавлять в него элементы в нулевую позицию (в условный хвост) -- это стандартный метод enqueue(). Удаление элемента из головы, и его выдача, происходит методом dequeue().

Для реализации очереди, длина которой заведомо не превысит некоторого размера, тоже можно использовать массив. Применяется схема т.н. кругового буфера, когда некоторую последовательность мы записываем внутри массива (начало не имеет значения), запоминая её первый и последний элемент в двух переменных-индексах (или одной переменной-индекса -- начало очереди, и её текущей длины). Добавление/удаление элемента требует лишь записи элемента по соответствующему индексу и его сдвига. Надо только аккуратно учесть случай, когда один из этих индексов выходит за одну из границ массива [B16].

Очереди и стеки как стандартные структуры данных очень хороши тем, что, моделируя естественные схемы работы всевозможных сущностей реального и виртуального мира, предоставляют очень компактный интерфейс, не позволяющий делать ничего лишнего [CS106B].

Для любой фактически структуры данных, в том числе и очереди, может быть реализована её т.н. персистентная версия (хранящая всю историю изменений). Этот подход активно применяется в функциональном программировании, где все структуры данных по умолчанию иммутабельны (закрыты для изменений), поэтому любая операция над ними, меняющая состояние, создаёт новую структуру данных. Например, операция добавления элемента в очередь создаёт новую очередь с новым элементом в хвосте, и т. д. Зачем нужна персистентность, не достаточно ли простой иммутабельности? Дело в том, что если очередь хранит много элементов, то создавать её полную копию при каждом добавлении или удалении элемента крайне неэффективно (O(N)). А персистентная структура допускает создание копии через простое запоминание, какой элемент был добавлен, без формирования полного клона. Фактически мы выдаём некоторым внутренним образом каждую новую версию, используя одни и те же оригинальные элементы. Недостатком такого подхода становится необходимость хранить всю историю изменений целиком, и определённую внутреннюю сложность алгоритмов персистентности [COS226].

```
qu = Queue()
qu.enqueue(1)
qu.enqueue(2)
qu.enqueue(3)
while qu.size() > 0:
    print(qu.dequeue())
```

## Задания.

6.1. В классе Queue нам понадобятся три метода: size() (количество элементов в очереди), enqueue(item) -- добавить элемент в хвост очереди, и dequeue(), которая возвращает элемент из головы очереди, удаляя его.

6.2. Оцените меру сложности для операций enqueue() и dequeue().

6.3. Напишите функцию, которая "вращает" очередь по кругу на N элементов.

6.4. Попробуйте реализовать очередь с помощью двух стеков.