# Графы
__Граф__ -- это пожалуй самая универсальная структура описания данных, которые связаны друг с другом. Графы немного похожи на деревья (точнее, деревья являются частным случаем графов), однако применяются они для совсем иных задач.

Граф -- это набор узлов (называемых __вершинами__), между которыми могут быть заданы связи (называемые __рёбра__, или иногда __дуги__). Классический пример графа -- это карта транспортных взаимосвязей между городами, где города выступают в роли вершин, а маршруты между ними -- в виде рёбер. Если между двумя городами существует прямой маршрут, то они связываются ребром.

В общем случае любая вершина графа может быть связана с любыми другими вершинами, а может и не быть не связана ни с кем.

Если две вершины соединены одним ребром, то они называются смежными.
Между двумя вершинами возможен путь -- цепочка промежуточных вершин, связанных друг с другом рёбрами, приводящая из исходной вершины в конечную.
Если в графе можно добраться из любой вершины к любой другой вершине, то он называется связным.
Рёбра графа могут иметь направление (путь по нему возможен только в одну сторону), это направление указывается стрелкой на конце. Граф с направленными рёбрами называется ориентированным (или направленным :).
В таком случае рёбра теоретически могут замыкаться в кольцо, и при движении по ним могут возникать бесконечные циклы. Соответственно, ориентированные графы с такими кольцами называются циклическими, а без оных -- ациклическими.

Кроме того, ребро может иметь свой вес (числовую характеристику) -- например, реальную протяжённость маршрута в километрах. Граф с такими рёбрами называется взвешенным.

В традиционных графах веса ребер обычно представлены в виде целых или плавающих чисел, однако, как отмечается в CS124, рёбра в общем случае могут иметь произвольные типы весов, вплоть до сложных отношений или атрибутов.
В дополнение к произвольным весам рёбер, допускаются также аннотации ребер: дополнительная информация, например, временные метки или геопространственные координаты.

Существуют также мультиграфы -- графы, у которых между одними и теми же двумя узлами допускается несколько рёбер (например, несколько дорог (федеральная и платная) между городами) [CS124].

Сам по себе граф -- явно рекурсивная структура данных, где узлы связаны с другими узлами. Это более свободная форма, нежели дерево: в графе нету корневого узла, который занимает особое место, и нету такого ограничения, что существует только единственный путь в дереве от вышестоящего узла к нижестоящему. Таким образом, циклов в дереве нет. А в графе узлу допускается любое количество указателей на другие узлы. Потенциально у него может быть даже ноль указателей -- он может находиться на маленьком собственном "острове", у которого нет ни входящих, ни исходящих рейсов.
Кроме того, нет правила, говорящего о том, что у вас не может быть нескольких способов добраться до одного и того же узла. Вы можете выбрать и более короткий маршрут, и более длинный. При этом возникает опасность попадания в петли, в зацикленные маршруты [CS106B].

Вершины графа обычно представляются объектами определённого класса.
Например, удобно определить класс City с набором свойств, если мы хотим реализовать карту маршрутов между городами.
Все вершины (объекты) пронумерованы и хранятся в массиве. Индекс объекта в массиве можно считать номером соответствующей вершины.

Как эффективнее всего вытащить всех соседей некоторого узла? Хотелось бы их хранить таким образом, чтобы до них было легко добраться. Есть два способа, которые пытаются представить смежность узлов эффективным способом: список смежности и матрица смежности.

Связи между вершинами предоставляются двумя способами.
1. Матрица смежности -- матрица размером NxN элементов, где N -- количество вершин в графе. Каждый элемент матрицы просто определяет (например, логическим значением), имеется ли связь (ребро) между узлами i и j.
2. Список смежности -- для каждой вершины (например, по её номеру-ключу) хранится список всех смежных с ней вершин.

В графе не существует отдельного корневого узла, и вы даже не можете произвольно выбрать один из узлов графа в качестве корня, потому что на самом деле нет никакой гарантии, что он подключён хотя бы к одному другому узлу. Так что, как правило, вам действительно нужно работать со всей коллекцией узлов, причём необходимо обычно также поддерживать довольно обширное множество других соединений, которые создаются на связности графа.

Если соединений много, то граф называется плотным. Однако в графе могут быть тысячи узлов, но, возможно, в среднем только три или четыре из них будут связаны. Тогда выделение 1000 слотов, из которых заполнены только три, может стать довольно неэффективным с точки зрения использования памяти. Тут можно предпочесть представление в виде списка смежности, когда O(N) невелико [CS106B].

Выбор подходящего варианта представления связей зависит от специфики решаемой задачи. У каждого из них есть свои плюсы и минусы. Например, если ребро имеет вес, то его требуется как-то хранить, для чего потребуется расширить матрицу или список хранением уже не просто числовых данных, а более сложных структур.

Связи, соединяющие узлы, часто играют реальную роль с точки зрения данных. Может быть, они говорят вам, по какой дороге вы сюда едете, или какова длина этого пути, или сколько стоит этот рейс, или во сколько отправляется этот рейс, или насколько уже заполнен этот рейс, или просто другая информация, которая больше, чем просто один узел, связанный с другим [CS106B].

Но чаще всего для не-взвешенных графов используется матрица смежности, причём правило проверки в ней таково, что мы уславливаемся всегда считать исходным узлом измерение 1 (или 2), а конечным -- измерение 2 (или 1), и никогда это правило не меняем. Оно важно, как будет понятно далее, в случаях, когда граф ориентированный.
![](https://skillsmart.ru/algo/15-121-cm/madj.jpg)


В классе графа SimpleGraph потребуются три поля:
- max_vertex -- максимальное количество вершин (исходя из конкретной задачи), чтобы сразу сформировать пустую матрицу смежности;
- m_adjacency -- матрица смежности, где 0 означает отсутствие ребра между i-й вершиной (первое измерение) и j-й вершиной (второе измерение), а 1 означает наличие ребра;
- vertex -- список vertex, хранящий вершины.

Каждая вершина будет экземпляром класса Vertex, хранящим некоторое абстрактное значение.

Каждая вершина однозначно идентифицируется своим индексом в списке vertex, который (индекс) также определяет связи через матрицу смежности.

Задание.

Реализуйте в классе SimpleGraph следующие методы:
- проверка наличия ребра между вершинами;
- добавление новой вершины, которая ни с какими другими вершинами не связана (тест: вершина имеется, связи с ней отсутствуют);
- добавление ребра между двумя заданными вершинами (тест: до добавления связи между вершинами не было, после добавления появилась);
- удаление ребра между двумя заданными вершинами (тест: до удаления связь между вершинами была, после удаления отсутствует);
- удаление вершины со всеми её рёбрами (тест: до удаления некоторые вершины имеют связи с удаляемой вершиной, после удаления этих связей нету).

Метод AddVertex() получает параметром значение (целое число), которое внутри метода надо преобразовать в объект типа Vertex.
RemoveVertex() в качестве параметра получает индекс удаляемой вершины.

