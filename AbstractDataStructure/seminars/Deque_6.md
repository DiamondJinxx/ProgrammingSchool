# Двусторонняя очередь (deque)
Это такое своеобразное расширение очереди и стека, у которого два входа (голова и хвост), и они же одновременно и выходы. То есть строгого правила, кто в каком порядке выходит, тут нету.

Такая структура данных позволяет добиться большей гибкости в некоторых задачах, когда например надо реализовать очередь с доступом по схемам и FIFO, и LIFO.

То есть нам требуются не два, а четыре основных метода: добавление/удаление объекта (голова) addFront(item)/removeFront(), и добавление/удаление объекта (хвост) addTail(item)/removeTail().
При этом сама внутренняя структура совмещает очередь и стек. Если мы работаем только с одной стороной Deque (например, только головой), то она функционирует как стек. А если мы помещаем элементы с одной стороны, а берём с другой, то получается очередь.
При реализации класса Deque с помощью стандартного списка (не связного, а обычного стандартного в Python, фактически массива) мы получим немного парадоксальный результат в плане эффективности.
Проблема здесь в том, что мера сложности нашей реализации сильно зависит от того, что в нашем внутреннем списке мы выберем головой, а что хвостом.

Например, addFront(item) может добавлять объект item в хвост списка/массива, что обычно выполняется быстро, а addTail(item) добавляет объект item в начало списка (вставляет в 0-й элемент), что часто требует сдвига всех последующих элементов.
Это зависит от внутреннего представления стандартного списка в конкретной реализации вашего языка программирования, но так как он поддерживает возможность индексации (ведёт себя как массив), внутри он наверняка реализован как динамический массив, иначе невозможно обеспечить доступ к элементам по индексу за O(1). А в динамическом массиве при вставке элемента приходится сдвигать все последующие элементы.

```
deq = Deque()
deq.addFront("f1")
deq.addTail("t1")
deq.addFront("f2")
deq.addTail("t2")
while deq.size() > 0:
    print(deq.removeFront())
    print(deq.removeTail())
```

Проблема здесь в том, что мера сложности нашей реализации сильно зависит от того, что в нашем внутреннем списке мы выберем головой, а что хвостом.

## Задания.

7.1. Почему и как будет различаться мера сложности для addHead/removeHead и addTail/removeTail?

7.2. Напишите функцию, которая с помощью deque проверяет, является ли некоторая строка палиндромом (читается одинаково слева направо и справа налево).

7.3. Добавьте для каждого из четырёх вышеупомянутых методов тесты: проверяйте изменившуюся длину очереди и наличие или отстутствие в ней добавляемого/удаляемого элемента.