# Деревья
Деревья -- это один из фундаментальных типов данных, который часто применяется в практических проектах. Дерево состоит из __узлов__, у каждого из которых может быть некоторое (в общем случае произвольное) количество дочерних узлов, связанных с родительским так называемой __ветвью__. Узел, у которого нету ни одного дочернего узла, называется __лист__.

Классический пример дерева:



Хороший пример дерева (с некоторыми оговорками) -- файловая система.

Реализуется дерево достаточно просто. Каждому узлу дерева достаточно хранить:
1) некоторое значение,
2) указатель на родительский узел (в общем случае необязателен, но очень желателен для быстрого выполнения различных операций),
3) список дочерних узлов.

Полезной в ряде задач характеристикой узла считается уровень дерева. Он показывает, сколь глубоко относительно корневого узла находится данный узел. Фактически, это длина кратчайшего пути из корневого узла в данный, выраженная в количестве ветвей.
Впрочем, говорить "кратчайший" не совсем корректно: в дереве не существует двух разных путей добраться до некоторого узла из вышестоящей вершины. Подразумевается, что в дереве нет цикличности или петель, и у каждого узла всегда один родитель (кроме корня, у которого родителя нету) [CS106B].

Само дерево в простейшем виде (допустим, класс SimpleTree) реализуется также максимально просто: это в общем случае всего лишь корневой элемент дерева. То есть в классе SimpleTree достаточно завести только одно поле, root, хранящее либо корневой узел, либо отсутствие значения.

Какие операции в классе SimpleTree нам потребуются:
- добавить текущему узлу (первый параметр метода добавления узла) новый узел (второй параметр метода добавления узла) в качестве дочернего (тест: проверяем наличие добавленного узла);
- удалить некорневой узел (удаляется узел вместе со всем поддеревом) (тест: проверяем отсутствие удалённого узла и его потомков);
- последовательно обойти всё дерево и сформировать список всех узлов в произвольном порядке;
- найти список подходящих узлов по заданному значению (тест: проверяем результат с тестовым списком);
- переместить некорневой узел дочерним узлом в другое место дерева (вместе с его поддеревом), для чего воспользуйтесь предыдущими методами (тест: проверяем, что узел отсутствует там где был исходно и появился в новом месте);
- подсчитать общее количество узлов в дереве, и количество листьев (тест: проверяем на контрольном дереве количество узлов и листьев).

Также напишите метод, который перебирает всё дерево и прописывает каждому узлу его уровень.
Деревья очень "рекурсивны", наиболее удобно и правильно думать о них именно в парадигме рекурсивных вычислений [CS106B].

Придумайте, как лучше организовать поддержку уровня узлов без анализа всего дерева.

Порекомендую полезный ресурс, где можно визуально поизучать некоторые структуры и алгоритмы с данного курса: chrislaux.com