# Двоичные деревья поиска
На практике очень часто применяется простая разновидность деревьев -- так называемые __двоичные деревья__. Каждый узел двоичного дерева содержит не более двух потомков, причём каждый из них однозначно идентифицируется как левый или правый. У узла могут быть оба потомка (левый или правый), а также один левый или один правый (это разные ситуации), или не быть ни одного потомка.

Двоичные (бинарные) деревья могут быть полными (в том числе частично), строгими, законченными.

__Полное бинарное дерево (full binary tree)__ -- это дерево, где каждый узел либо лист, либо у него обязательно есть два наследника. Все листья должны быть распложены на одном уровне. Другими словами, у полного дерева все уровни заполнены полностью.

![](https://skillsmart.ru/algo/15-121-cm/tbin15.png)

__Строгое бинарное дерево (strictly binary tree)__ -- это дерево, каждый узел которого либо лист, либо у него ровно два потомка.

![](https://skillsmart.ru/algo/15-121-cm/trbin16.png)

__Законченное бинарное дерево (complete binary tree)__ глубины (уровня) n -- это полное дерево уровня n-1, в котором дополнительно разрешается узлам уровня n-1 иметь 2, 1 или 0 потомков (листьев).

![](https://skillsmart.ru/algo/15-121-cm/trbin17.jpg)


__Почти полное бинарное дерево__ (к таковым иногда относят и законченные бинарные деревья, как ни удивительно, но по поводу единой терминологии споры не прекращаются) -- это законченное бинарное дерево, где все листья дополнительно сдвинуты влево, как на изображении выше. Законченное бинарное дерево из него можно получить, переместив например узел L к родителю G.
Своеобразная непрерывность нижнего уровня добавляется к почти полным бинарным деревьям.

Отличительная особенность двоичных деревьев в том, что во-первых, они обеспечивают быстрый поиск информации (O(log n)), а во-вторых, они позволяют быстро добавлять и удалять информацию, буквально единичными операциями. Например, если применить для этого упорядоченный массив, то в нём можно отыскивать нужный элемент логарифмическим поиском (рассматривается в следующих уроках). Однако вставка или удаление элемента требует уже сложности O(n), так как необходимо сдвигать элементы массива. Наоборот, операции вставки и удаления быстро выполняются в списках -- но зато поиск в них требует времени порядка O(n).

Помимо стандартных операций, таких как вставка, удаление и поиск элементов, двоичное дерево также поддерживает "частичное каскадирование" (fractional cascading) -- когда ведётся поиск одного значения сразу в нескольких деревьях.
Кроме того, так как поддеревья в разных ветках независимы друг от друга, процесс поиска удаётся хорошо распараллелить, главное -- аккуратно синхронизировать работу нескольких потоков поиска [CS124].

Узел двоичного дерева уже не будет хранить список дочерних узлов, достаточно двух явно определённых потомков, например left_child и right_child.

Мы также храним в узле ключ -- идентификатор, по которому и происходит упорядочивание и поиск данных. Для общего случая добавим и поле value, которое хранит основное значение, если значения самого ключа недостаточно.

Класс двоичного дерева BinarySearchTree сам по себе простой: ему всё так же достаточно одного корневого узла root.

Ключевых отличий двоичного дерева поиска от обычного два:
1. Все данные в дереве хранятся в определённом образом упорядоченном виде;
2. Поиск выполняется с учётом этой упорядоченности.

Операция поиска должна выдавать либо факт присутствия ключа в дереве, либо родительский узел, которому надо добавить новый узел в качестве потомка, и признак, каким этот узел добавляется -- левым или правым.

А вот удаление вызывает проблемы. И хотя в случае, когда у узла ноль или один потомок, оно тривиально, если существуют оба потомка, требуются дополнительные усилия. Чтобы разобраться в этом случае, сначала разберёмся с функцией поиска.

Поиск тесно связан со схемой хранения значений (ключей) в двоичном дереве. Правило таково:
__ключ левого потомка должен быть меньше ключа родителя, а ключ правого потомка должен быть больше ключа родителя.__

![](https://skillsmart.ru/algo/15-121-cm/tbin15.png)

В общем случае допускается вариант, когда в дереве могут храниться одинаковые ключи, в таком случае действует правило:
__ключ правого потомка должен быть больше или равен ключу родителя__

Подобные деревья называются частично упорядоченными. Далее мы рассматриваем только полностью упорядоченные деревья. Однако на практике и в таких деревьях бывает нужно вести учёт количества одинаковых ключей, добавляемых в дерево. В таких случаях в узел просто добавляется счётчик ключей.

Соответственно, и поиск нужного узла происходит так: начиная с корня дерева, сравниваем ключ поиска с ключом текущего узла. Если ключ поиска меньше ключа текущего узла, переходим к левому узлу, иначе переходим к правому узлу.
В итоге мы либо добираемся до листа дерева с искомым значением, либо левый (правый) узел текущего узла отсутствует (значение не определено). Функция поиска должна выдавать список из трёх значений, первое из которых -- узел, а второе равно true, если этот узел содержит нужный ключ, или равно false, если этот узел родительский и ему требуется создать новый узел. В последнем случае третье значение показывает, какому полю-потомку (левому или правому) родительского узла надо присвоить новый узел.

Из такой функции прозрачно следует метод добавления узла: если ключ не найден, то у нас уже есть конкретный узел, которому надо добавить новый узел с новым ключём.

Кроме того, двоичное дерево позволяет очень быстро находить максимальное и минимальные значения. Минимальное значение мы получим, если будем спускаться по дереву всё время по левым потомкам, а максимальное получим, если будем спускаться по дереву всё время по правым потомкам.

Теперь вернёмся к удалению узла с двумя потомками. Проблема в том, что нельзя просто взять и заменить узел одним его потомком, потому что тут возможны конфликтные ситуации, связанные с упорядоченностью ключей. Не будем углубляться в эту ситуацию, воспользуемся следующим правилом: удаляемый узел надо заменить так называемым узлом-преемником, ключ которого -- наименьший из всех ключей, которые больше ключа удаляемого узла.
Иными словами, нам надо взять правого потомка удаляемого узла, и далее спускаться по всем левым потомкам. Если мы находим лист, то его и надо поместить вместо удаляемого узла. Если мы находим узел, у которого есть только правый потомок, то преемником берём этот узел, а вместо него помещаем его правого потомка.

Реализуйте:
- метод поиска (тест: проверяем поиск отсутствующего ключа в двух вариантах (запрошенный ключ добавляем либо левому, либо правому потомку) и поиск присутствующего ключа);
- метод добавления нового узла, задаём добавляемый ключ и соответствующее ему значение (тесты: проверяем исходное отсутствие узла по такому ключу в дереве и его наличие после добавления, в двух вариантах -- левым или правым узлом родителя, а также попытку добавления ключа, которое уже имеется в дереве, в таком случае ничего с деревом не делаем);
- поиск максимального и минимального ключей, начиная с заданного узла (тест, 4 варианта: поиск начиная с корня и поиск начиная с поддерева, ищем максимальный и минимальный ключ);
- метод удаления узла по его ключу (тест: проверяем исходное наличие узла у родителя, его отсутствие после удаления, и результат работы метода).

# Способы обхода дерева
В первом занятии вы самостоятельно придумали некий способ обхода дерева для поиска нужного элемента. Существует формальный перечень таких способов, который делится на две группы: обход в глубину и обход в ширину. Эти методы универсальны -- работают для деревьев любой структуры.
В прошлом занятии мы рассматривали двоичные деревья, для которых в силу их структуры возможна совсем простая схема поиска, но в общем случае придётся придерживаться одного из двух следующих подходов.

## 1. Обход в глубину

Этот рекурсивный алгоритм подразумевает, что находясь в некотором узле, мы проверяем на наличие искомого объекта, в некотором порядке, левое поддерево (рекурсивно), текущий узел, правое поддерево (рекурсивно). Например, только что описанный порядок обхода называется симметричный (in-order). Если текущий узел (корень) проверяем в последнюю очередь, порядок будет post-order, и если корень проверяем самым первым, порядок будет pre-order.

Зачем придуманы такие порядки? Вроде бы непринципиально, когда проверять корень, в начале или конце. Далее мы будем изучать двоичные деревья поиска, в которых значения узлов определённым образом упорядочены, вот там конкретный порядок и становится актуальным. Как правило, применяется in-order.

Если in order, то первым будет самый маленький (так как мы сперва берём левые), а последним самый большой узел, то есть мы получаем отсортированные ключи.
Post order первыми выдаст листья, самые нижние узлы (так как корень берём в последнюю очередь), что удобно, если нам нужно проверять первыми именно листья и искать снизу вверх.
Pre order удобен, если мы хотим искать нужный ключ, начиная с корня, сверху вниз.
Они отличаются и по эффективности работы, и по эффективности реализации, если мы знаем что-то о структуре дерева, о данных в нём, то выбор подходящего метода может очень сильно дать выигрыш в скорости.

## 2. Обход в ширину

Этот алгоритм проверяет сначала все узлы 1-го уровня (фактически, один корень), затем все узлы второго уровня (фактически, всех наследников корня) -- слева направо, затем узлы третьего уровня (наследники всех наследников) и т. д. В зависимости от реализации дерева алгоритм может быть и итеративным, и рекурсивным -- всё зависит от того, насколько эффективно удаётся отобрать узлы N-го уровня.

В каких случаях применяются способы этих двух групп? На практике не всегда известно, какого объёма дерево. Например, если оно относительно неглубокое, но очень широкое, то лучше использовать поиск в глубину, а если глубокое и очень узкое, то лучше использовать поиск в ширину.

## Задание
1. Реализуйте дополнительный метод обхода дерева WideAllNodes() без параметров для класса из занятия по двоичным деревьям, так, чтобы он реализовывал алгоритм поиска в ширину, начиная с корня.

2. Реализуйте дополнительный метод обхода дерева DeepAllNodes(), начиная с корня, которому задаётся один целый параметр, принимающий значения 0 (in-order), 1 (post-order) и 2 (pre-order). В зависимости от этого параметра метод DeepAllNodes() реализует соответствующую форму алгоритма поиска в глубину.

Эти алгоритмы формируют на выходе стандартный список из объектов BSTNode (List в C#, tuple в Python, ArrayList в Java).

НЕправильная сигнатура:

ArrayList<BSTNode<T>> WideAllNodes() // Java
List<BSTNode<T>> tree.WideAllNodes() // C#
Правильная сигнатура:

ArrayList<BSTNode> WideAllNodes() // Java
List<BSTNode> tree.WideAllNodes() // C#