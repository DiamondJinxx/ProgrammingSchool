Поиск пути в графе (обход в глубину)
Наиболее востребованная возможность графов -- это проверка, существует ли путь из вершины А в вершину Б. Поиск по графу -- очень актуальная задача поиска пути, этим занимаются и Google Maps, и все эти GPS-навигаторы.

Для этой структуры данных придумано множество самых разных алгоритмов. Например, алгоритм Дейкстры находит кратчайший путь между двумя узлами для графов, у которых рёбрам заданы веса (например, расстояния между городами), минимизируя не число рёбер на пути, а веса рёбер. Затем было придумано его более эффективное расширение -- поиск А* . Затем алгоритм Дейкстры, который не работал с графами, рёбра которого имели отрицательные веса, был сделан универсальным (поиск Форда-Беллмана) [B16].

Мы рассмотрим два стандартных алгоритма поиска на графе без весов рёбер, которые гарантированно либо находят путь, либо выясняют, что его не существует, при этом один из них попутно формирует оптимальный (кратчайший по количеству рёбер) путь.

Поскольку у нас есть структура графа, которая имеет свободную связность и допускает циклы и множественные пути к одному и тому же узлу, нужно быть немного осторожными в том, как мы делаем поиск, чтобы убедиться, что мы не застряли в каком-то бесконечном цикле.

Первый алгоритм -- это поиск пути через обход графа в глубину (путь находится неоптимальный, но ищется он быстро, и хорошо реализуется рекурсивно). Этому алгоритму потребуется стек.

Алгоритм Depth-first search (dfs) работает так:

0) Очищаем все дополнительные структуры данных: делаем стек пустым, а все вершины графа отмечаем как непосещённые (см. далее).

1) Выбираем текущую вершину X. Для начала работы это будет исходная вершина А.

2) Фиксируем вершину X как посещённую.
Для этого в класс Vertex надо добавить, например, флажок hit, который принимает значение True, если вершина была таким образом посещёна.

3) Помещаем вершину X в стек.

4) Ищем среди смежных вершин вершины X целевую вершину Б. Если она найдена, записываем её в стек и возвращаем сам стек как результат работы (путь из А в Б).
Если целевой вершины среди смежных нету, то выбираем среди смежных такую вершину, которая ещё не была посещена. Если такая вершина найдена, делаем её текущей X и переходим к п. 2.

5) Если непосещённых смежных вершин более нету, удаляем из стека верхний элемент. Если стек пуст, то прекращаем работу и информируем, что путь не найден. В противном случае делаем текущей вершиной X верхний элемент стека, помечаем его как посещённый, и после чего переходим к п. 4.

Расширьте класс SimpleGraph из позапрошлого занятия методом DepthFirstSearch(), который получает в качестве параметров два узла Vertex (начальный и конечный) -- узлы задаются индексами-позициями в списке vertex -- и возвращает список узлов, представляющий собой путь из начального узла в конечный. Список будет пустым, если пути не существует.
Реализуйте этот алгоритм с помощью стека.

