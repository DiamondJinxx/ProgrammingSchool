# Ассоциативный массив
Стек и очередь делают очень полезные вещи, но это в основном простое моделирование определённого поведения, которое легко использовать без ошибок. Ассоциативные контейнеры (к которым относят словари и множества из следующих занятий) -- это уже такие структуры данных, которые делают что-то, что на самом деле сложно, неудобно или неэффективно вручную. Они не о последовательности хранения, а об отношениях между данными [CS106B].

Хэш-таблицы хоть и реализованы в большинстве языков программирования, в стандартных библиотеках, однако напрямую используются редко, так как сами по себе не очень полезны. Однако существует такая очень популярная структура данных, как ассоциативный массив (или словарь), когда мы храним данные в формате ключ - значение. Такой массив отличается от обычного тем, что в качестве индексов выступают не целые числа, а произвольные значения (например, строки). Вот тут мы и находим точку пересечения с хэш-таблицами.

Кажется, было бы очень удобно, если бы мы могли сказать, что ключ является целым числом. Почему однако чаще всего используется строковый тип? Дело в том, что строки оказались самым удобным типом данных и в плане эффективности вычисления ключа, и в плане универсальности их использования [CS106B].

Стандартный словарь Python позволяет записать в переменную набор пар ключ-значение:

`my_dict = {"key1": "значение 1", "ключ 23": 512}`

и в дальнейшем получать нужное значение, указав ключ в качестве индекса:

`my_dict["ключ 23"] # 512` 

Можно изменять значения в словаре:

`my_dict["ключ 23"] = 1024`

Это такой сокращённый доступ с помощью синтаксиса, который в данном контексте всё же выглядит немного странным. Мы обращаемся к словарю как с массиву, указывая просто значение ключа в квадратных скобках. По большому счёту, это злоупотребление системой обозначений в том смысле, что тут нету явного "возражения", если вы попытаетесь получить доступ к ключу, которого не существует, ну и сама по себе такая запись, напоминающая массив, может вызывать проблемы, когда этот же синтаксис используется и для получения существующего значения, и для добавления (перезаписывая или добавляя новое значение), и его легко спутать с более безопасной индексацией обычного массива, где "несуществующих" ситуаций не возникает [CS106B].

Потенциально словарь прозрачно поддерживает ограничение действия ключей-значений по времени, вплоть до задания срока действия для каждого ключа/значения, по истечении которого пара будет автоматически удалена, что бывает полезно, когда словарь используется для кэширования или временного хранения данных. Ключ и/или значение сопровождаются дополнительным полем "срок действия", а когда оно устаревает, никаких особых действий не требуется. Просто в следующий раз, когда будет выполнено обращение к такому просроченному ключу, его надо просто сперва удалить [CS124].

Для реализации ассоциативного массива воспользуемся хэш-таблицей, реализованной в предыдущем занятии. По сути, требуется лишь дополнить ее вторым массивом self.values -- в дополнение к массиву self.slots, который будет хранить ключи.
self.values по размеру будет таким же, как и self.slots, а записываются в него значения, соответствующие ключу слота (с таким же индексом).

Главное отличие ассоциативного массива от хэш-таблицы в том, что он обычно не ограничен каким-то фиксированным размером (количеством ключей), и либо исходно под конкретную задачу создаётся с гарантированным запасом по размеру, либо сочетает возможности хэш-таблицы и динамического массива.

Если по каким-то причинам реализация с хэш-функциями не подходит (например, возникает слишком много коллизий), то для реализации словаря вполне можно использовать упорядоченный массив фиксированного размера, который хранит, например, объекты с двумя полями ключ и значение.
Другой вариант -- использовать для реализации словаря двоичное сбалансированное дерево, где поиск ключей происходит очень эффективно (все важные виды поиска проходим на курсах по деревьям графам и сортировкам). Но сама реализация будет сложнее, она подразумевает работу с указателями и динамическим выделением памяти, а изменение структуры дерева (добавление новых узлов и балансировка) может требовать дополнительных накладных ресурсов, если, например, счёт идёт на миллионы элементов.

У словаря есть такая особенность, что когда вы просите значение по ключу, которого не существует, возникнет небольшой вопрос, что возвращать. Если например словарь хранит числа, то мы не можем вернуть 0 или -1 как "признак" отсутствия ключа, т.к. это тоже полноценные числа. Довольно кривое решение -- возвращая None в случае отсутствия ключа, что и предлагается в шаблонах решения. Однако есть гораздо более правильный подход (через абстрактные типы данных), который мы изучаем на треке 2.b (объектно-ориентированный анализ и проектирование), где как раз разбираем, как действительно правильно реализовывать структуры данных с данного курса.

В принципе, в классическом словаре нету операции извлечения всех ключей - в частности, потому, что это неэффективная операция, и ей могут слишком активно бездумно пользоваться. Кроме того, подобное действие само по себе признак слабости алгоритма (зачем вам нужны все ключи? может, лучше использовать другую структуру данных?). И ещё нюанс, что хотя в современных стандартных библиотеках обычно можно получить список всех ключей, однако даже их фиксированный порядок от выхова к вызову не гарантирован. Например, в первый раз могут быть выданы ключи ["key123", "mykey007"], а во второй ["mykey007", "key123"].
На этой особенности словарей один из специалистов сделал шутливый генератор случайных последовательностей.

Если количество ключей в словаре явно слишком большое (и потенциально возможно частое возникновение коллизий), имеет смысл придерживаться какой-то стратегии разделения входных данных на сегменты. Простейший пример -- при хранении фамилий создавать словарь из словарей, где каждый вложенный словарь доступен по ключу первой буквы фамилии. Если данные -- достаточно равномерный случайный числовой код, первые его несколько цифр тоже можно использовать как ключи для хранения вложенных словарей, или даже создать массив, хранящий 1000 словарей (если первые три цифры кода случайны) и т. п. [CS106B]

Словарь вполне можно (и нужно) расширить поддержкой параллельного доступа для чтения и записи, что позволяет нескольким потокам одновременно обращаться к словарю и менять его содержимое, не вызывая повреждения или несогласованности данных. Чтение само по себе консистентности не нарушает, а вот для записи потребуется некоторая простая форма транзакций (пока одна операция записи по ключу не отработала, другие операции записи по этому же ключу ждут в очереди её полноценного завершения) [CS124].

### Реализуйте три метода:

- put(key, value) - сохранение внутри класса ассоциативного массива пары ключ-значение по описанной выше схеме;

- is_key(key) - проверка, имеется ли в слотах такой ключ;

- get(key) - поиск и извлечение значения по ключу, или None, если ключ не найден.

### Сделайте тесты, проверяющие, как работают put(), is_key() и get():
- добавление значения по новому ключу и добавление значения по уже существующему ключу с проверками что записалось, проверка присутствующего и отсутствующего ключей, извлечение значения по существующему и отсутствующему ключу.