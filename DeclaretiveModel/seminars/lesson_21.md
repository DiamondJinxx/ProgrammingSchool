# 21. Преобразование рекурсивных вычислений в итеративные
Вернёмся к функции определения длины списка.

function Len(lst)

    if lst == []
        return 0
    end

    head = lst[1]
    tail = lst[2:end]

    return 1 + Len(tail)

end
Она работает за линейное время, однако всё ещё требует стек размером n (длина списка-параметра). Почему так происходит? Потому что прибавление +1 в заключительном return происходит уже после рекурсивного вызова Len(tail). Вызывающему окружению необходимо "сохраниться" (в частности, запомнить точку возврата в функцию в стеке), о чём уже говорилось -- по сути только для того, чтобы прибавить 1 к результату и сразу его вернуть.

Ранее мы уже обсуждали итеративную схему как последовательность трансформации состояний. В её формате процедуру вычисления длины списка можно представить как последовательность перехода от состояния к состоянию, где каждое состояние -- это пара {длина уже обработанного списка, оставшийся список}. Начальное состояние S0 -- это (0, исходный список), а конечное состояние Sn (для списка длиной n) -- это (n, пустой список). Промежуточное состояние Si -- (i, хвост списка от i+1 до n).

Переведя этот подход в рекурсивный вид, мы получим функцию, которая получает два параметра (длина списка и оставшийся список), увеличивает длину на +1 и удаляет из списка первый элемент.

function IterLen(i, lst)
    if lst == []
        return i
    end
    return IterLen(i+1, lst[2:end])
end

println(IterLen(0, [1,2,3,5,8])) # 5
Теперь увеличение счётчика i на 1 выполняется не после, а до рекурсивного вызова, и так как он последний в коде функции, сохранять её состояние в стеке не требуется. Фактически мы получили рекурсивную версию итеративной схемы расчёта.

Применим теперь аналогичную технику к функции обращения списка. В качестве состояния снова будем использовать пару {уже обращённая часть списка, оставшаяся необработанной часть списка}.

function IterRev(Rs, Ys)
    if Ys == []
        return Rs
    end

    head = Ys[1]
    tail = Ys[2:end]
    return IterRev(pushfirst!(Rs,head), tail)
end

println(IterRev([], [1,5,3,7,9])) # [9,7,3,5,1]
Чтобы обеспечить пользователя удобством вызова подобных рекурсивных функций, требующих дополнительный параметр, используется "обёртка" в виде родительской функции, вызывающей рекурсивную функцию с начальным аргументом. Нередко, в частности, в такой схеме рекурсивная функция определяется непосредственно внутри родительской функции.

Например:

function Revers(Rs)

  function IterRev(Rs, Ys)
    if Ys == []
        return Rs
    end
    head = Ys[1]
    tail = Ys[2:end]
    return IterRev(pushfirst!(Rs,head), tail)
  end

    return IterRev([], Rs)
end

println(Revers([1,5,3,7,9])) # [9,7,3,5,1]
Функция Revers работает за линейное время и не требует стека.

