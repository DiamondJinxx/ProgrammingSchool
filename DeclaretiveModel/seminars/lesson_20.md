# Программирование с применением рекурсии.
## Программирование со списками

Рекурсивные вычисления -- это сердце декларативного программирования.

Списки -- очень лаконичный тип данных, и в то же время потенциально такой мощный, что позволяет закодировать любую сложную структуру данных. Декларативное программирование работы со списками получается простым и выразительным и предлагает следующие базовые подходы:
- рекурсивное мышление: как решать задачу в терминах более простой задачи;
- преобразование рекурсивных вычислений в итеративные (обычно в рекурсивных вычислениях размер стека растёт пропорционально размеру списка);
- выяснение правильности итеративных вычислений (простой и мощный способ -- через инварианты состояний);
- конструирование программ на основе системы типов (функция, работающая с некоторым типом, почти всегда имеет рекурсивную структуру, очень близкую к определению типа).

Рассмотрим эти подходы более подробно.

# 20. Рекурсивное мышление 

Список -- рекурсивная структура данных, определённая в терминах более маленькой версии себя. Напомню определение, которое мы давали списку: это либо nil (отсутствие значения), либо некоторое значение, сцепленное с последующим списком-"хвостом".
Поэтому функция для работы со списками будет состоять из двух частей: - базовый случай, для небольших списков (ноль, один или два элемента) результат возвращается сразу; - рекурсивный случай, для крупных списков функция вычисляет результат в терминах результата из более мелких списков.
Простая рекурсивная функция, вычисляющая по такой схеме длину списка:
```
function Len(lst)

    if lst == []
        return 0
    end

    head = lst[1]
    tail = lst[2:end]

    return 1 + Len(tail)

end
```

Другой пример: функция, которая должна объединить два списка, сформировав из них третий список. По индукции разбор надо начинать с первого списка.
```
function Append(Ls, Ms)

    if Ls == []
        return Ms
    end

    return pushfirst!(Append(Ls[2:end], Ms), Ls[1])

end
```
Смысл в том, что мы выделяем голову из первого списка, рекурсивно вызывая Append() для хвоста первого списка и второго списка, после чего добавляем эту голову к результату рекурсии. Мы как бы "выносим" голову первого списка из рекурсии наружу. И так как функция всегда работает только с первым аргументом, постоянно его уменьшая, она гарантированно закончится (это важное требование к декларативным программам).
Операции pushfirst! и подобные ей конечно не входят в декларативную модель, так как непосредственно модифицируют значения списка-аргумента. В декларативной модели операции над списками обычно создают новые списки, поэтому они практически всегда низкоэффективны, за исключением добавления элементов в голову или хвост, хотя это тоже зависит от реализации.

# Рекурсивные функции и их области определения
Определим функцию Nth, которая возвращает N-й элемент списка:

```
function Nth(Ls, N)
    if N == 1
        return Ls[1]
    elseif N > 1
        return Nth(Ls[2:end], N - 1)
    end
end

println(Nth([1,3,5], 3)) # 5
```
Но что случится, если мы вызовем Nth([1,3,5], 5)? В данном случае возникнет исключение BoundsError (выход за границы списка/массива). Исключение возникнет также, если N будет равно нулю, и т. д.

Отсюда следует общая техника определения функций: генерировать явные исключения, когда значения параметров находятся вне области определения функции. Однако гарантировать такой контроль весьма трудоёмко (возможны в частности ситуации, когда аргументы окажутся других типов, и т. п.). Компилятор Julia, в отличии, например, от компилятора Java, не отслеживает обязательное завершение всех веток функции, поэтому в динамически типизированных языках это будет проблемой. Тут желательно использовать различный синтаксический сахар, повышающий наглядность и выразительность кода, зависящего от диапазона некоторых параметров.
Наивные определения часто неэффективны

# Как "естественно" реализовать рекурсивную функцию обращения (перевёртывания) списка?

function Rev(Ls)
    if Ls == []
        return []
    end

    head = Ls[1]
    tail = Ls[2:end]
    return push!(Rev(tail), head)
end

println(Rev([1,5,3,7,9])) # [9,7,3,5,1]

Какой примерно будет её производительность? Для списка длиной n придётся сделать n рекурсивных вызовов, и n добавлений элемента в список. Функция push!() в среднем обрабатывает список длиной n/2 элементов, поэтому общая эффективность Rev() будет пропорциональна n*n/2, или по сути O(n*n). Чем длиннее список, тем сильно дольше будет работать такая функция. Кроме того, данная функция имеет ещё один неприятный дефект: для её работы потребуется стек вызовов глубиной n, и если например надо обратить список из миллиона элементов, вполне возможен классический stack overflow.

Любой программист с базовыми навыками, знакомый с императивным языком (например, Java или Python), напишет функцию обращения списка с эффективностью O(n): в одном цикле просто брать i-й от конца исходного списка элемент, и добавлять его в хвост результирующего списка. Поэтому существуют техники, позволяющие превращать такие рекурсивные функции в функции с итеративной формой вычислений, чья эффективность линейна.

