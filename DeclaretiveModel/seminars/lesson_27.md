# 27. Персистентные очереди и объекты

Самый простой наивный способ -- хранить каждое состояние как отдельную очередь, и организовывать доступ к её содержимому в режиме "только чтение" (неизменяемая, immutable-очередь). Однако если в очереди много элементов (тысячи, миллионы, ...) и она быстро изменяется, такой подход ведения истории оказывается крайне неэффективным и в плане быстродействия, и в плане использования памяти. Поэтому были придуманы различные специальные алгоритмы ведения истории распространённых структур данных.

Одна из известных проблем персистентных структур -- это неоднозначность их будущего, неоднозначность дальнейшего усложнения, которое начинает очень сильно зависеть от конкретной схемы работы со структурой, что делает затруднительным универсальный анализ учетных стоимостей. Можно конечно брать классическую наихудшую оценку, но она скорее всего будет сильно неэффективной и может существенно отличаться от реальной. Кроме того, персистентные структуры могут сильно разрастаться по критерию памяти, а работа сборщика мусора для них (ведение счётчиков ссылок на конкретные экземпляры в памяти) может стать ощутимо медленной. В некоторых случаях даже становится эффективнее обходить весь граф персистентной структуры в целом в поисках объектов, которые можно удалить из памяти. Вдобавок счётчики ссылок сами по себе по сути лишают систему иммутабельности.ти.```