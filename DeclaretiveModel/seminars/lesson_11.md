# 11. Исключения

Декларативная модель не способна обеспечить выразительную обработку ошибок, поэтому она обычно дополняется механизмом работы с исключительными ситуациями. От такого механизма требуются две вещи:

1) Каждый компонент должен уметь ограничить, изолировать ошибку, чтобы она не распространялась далее за пределы явно обозначенного "карантина". Ошибки, возникающие внутри компонентов, либо никак не влияют на их работу, видимую извне, либо компонент сообщает о них в чётком формате.

2) Компоненты могут иерархически вкладываться друг в друга, и требуется некоторая универсальная инструкция, которая позволяет выйти из компонента за его пределы. Если ошибка возникла где-то в глубинах иерархии, такая инструкция должна позволять "перепрыгивать" за один раз сразу через несколько уровней вложенности.

Декларативная модель не предоставляет такой возможности. В каждом компоненте (контексте) с помощью логических переменных и условий можно явно организовать подобный выход, но только за пределы текущего контекста, что, понятно, ощутимо усложняет код. Было доказано математически, что единственный способ в данном случае сохранить простоту программы -- это расширить оригинальную декларативную модель. Решается это добавлением двух команд.

# Команда try

Команда try контролирует некоторый подведомственный ей контекст, реагируя на возникающие в нём ошибки и предоставляя возможность задания реакций на них (обработки исключительных ситуаций). Программисту предоставляется возможность добавлять собственные виды исключений.

Как правило, данная команда состоит из инструкции try (начало контролируемого контекста), catch (блок, где обрабатываются различные виды возникших исключений), и else (блок, который выполняется, если исключения не возникло). Иногда она дополняется инструкцией finally со своим блоком, который выполняется в заключение всегда, независимо от того, возникла ошибка или нет. Это нужно, например, для выполнения некоторых "очистных" операций наподобие закрытия файла.
Названия этих инструкций и форма их работы и взаимосвязи между ними в разных языках программирования, конечно, могут различаться, однако общая схема -- набор минимальных требований к контролю исключительных ситуаций -- приведена выше.

Допускается опускать любые инструкции кроме начальной try.

# Команда raise

Команда raise выходит за пределы текущего контекста -- вызывает обработчик исключений за его пределами. Другими словами, ищется ближайшая к raise команда try (возможно, во вложенных внешних компонентах), в которой обрабатывается соответствующий вид исключений.

Сама по себе исключительная ситуация -- это значение (условный объект), ссылка на который (как декларативная переменная) передаётся механизмом обработки исключений в обрабатывающий код.

В общем случае возможна ситуация, когда такая переменная-исключение будет не определена (ещё не связана со значением): возникновение и перехват исключения и понимание, что это за исключение (наполнение объекта исключительной ситуации нужной информацией), могут выполняться параллельно. Это ещё один аргумент в пользу dataflow-переменных: с их помощью можно понять, что некоторая проблема уже возникла, хотя пока не ясно, что это конкретно за проблема.

