# 12. Динамическая и статическая типизация

Правильный язык программирования поддерживает строгую типизацию , то есть имеет систему типов, которая принудительно "навязывается" программисту. Существуют и языки со слабой типизацией, которые например допускают внутреннюю манипуляцию системой типов непосредственно из программы. Далее речь будет идти только о языках со строгой типизацией.

Строгая типизация в свою очередь подразделяется на динамическую и статическую типизацию. В динамически типизированных языках (декларативная модель динамически типизирована по умолчанию) подразумевается, что переменная может получить значение любого типа, то есть её тип определяется лишь во время работы программы, динамически. В статически типизированных языках тип каждой переменной всегда известен и либо явно задаётся программистом, либо автоматически выводится компилятором.

Статическая типизация накладывает ограничения на гибкость исходного кода, существенно снижая выразительность языка, однако характеризуется высокой способностью выявлять ошибки (в том числе и на этапе компиляции), высокой эффективностью, высокой безопасностью и возможностью частичной верификации формальной корректности программы.

Статическая типизация вылавливает основное количество ошибок на фазе компиляции. Вообще, хорошо продуманная система типов -- это важнейшая составляющая проекта, по сути частичная формальная спецификация программы, задающая её поведение. Так называемые type checkers (тайп-чекеры) в современных компиляторах весьма умны, и по спецификациям типов умеют также вылавливать весьма тонкие семантические ошибки.
Статическая типизация допускает весьма эффективную реализацию проекта, так как по каждой переменной известен тип, и компилятор может транслировать операции в наиболее оптимальный машинный код.
Статическая типизация обеспечивает высокую безопасность, потому что потенциально допускает конструирование весьма сложных типов, весьма глубоко контролирующих семантику программы.


# Динамическая типизация

Динамическая типизация фактически допускает исполнение любой программы, которая синтаксически корректна. Такая гибкость особенно хорошо ощущается опытными программистами, которым доступен широкий диапазон программистских техник и которые тратят существенно меньше времени на "выравнивание" кода по требованиям системы типов.

Динамическая типизация тривиально допускает раздельную компиляцию модулей, так как не требует от модулей никакой информации друг о друге. В результате становится возможной полноценная разработка очень больших систем, когда независимо создаваемые модули могут подключаться в режиме реального времени и сразу начинать взаимодействовать "на лету". В статической типизации это невозможно, так как проектная система типов должна явно "пронизывать" все модули.

Динамическая типизация серьёзно сокращает время от идеи до реализации, допуская пошаговую итеративную разработку и позволяя "в горячую" подключать к работающей системе модули, которые реализованы лишь частично.

# Выбор между динамической и статической типизацией

На практике однако выбор между динамической и статической типизацией чаще всего сводится к эмоциональному решению: тут ведутся многолетние холивары. В то же время различия между этими подходами не так велики, как кажется. Статическая типизация рекомендуется, когда проектное задание чётко сформулировано, методы его реализации хорошо понятны, а эффективность и качество имеют первостепенное значение. Динамическая типизация рекомендуется, когда требуется быстрая разработка в коллективе опытных программистов или быстрое создание прототипа, когда проект должен быть гибким насколько возможно (это типично в случаях, когда проектное задание отсутствует или невразумительно), а также при создании системных скриптов и проектов в области машинного обучения и data science.

Современные тенденции таковы, что статически типизированные языки (Java, C#, C++ ...) постепенно становятся гибче за счёт их расширения динамическими "фишками". Например, это различные виды полиморфизма в ООП, которые сохраняют хороший стиль программирования, допуская при этом проверки на этапе компиляции.

Кроме того, явный тренд -- это объединение в одном языке нескольких парадигм программирования.