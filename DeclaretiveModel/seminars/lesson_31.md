# 31. Обобщения

Сделать функцию "общей" -- значит, позволить любой конкретной сущности (т.е. любой операции или значению) становиться аргументом в теле функции. Такая сущность абстрагируется от функционального тела, а конкретно задается, когда функция вызывается непосредственно. Каждый раз при вызове функции может быть задана другая сущность.

Например:

```
function SumList(Ls)
    if Ls == []
        return 0
    end

    head = Ls[1]
    tail = Ls[2:end]
    return head + SumList(tail)
end

println(SumList([1,5,3,7,9]))
```
В функции SumList имеется нейтральный элемент 0, не влияющий на результат, и операция "+", которые можно обобщить до любого нейтрального элемента и любой операции (функции с двумя аргументами).

```
function FoldR(Ls, F, U)
    if Ls == []
        return U
    end

    head = Ls[1]
    tail = Ls[2:end]
    return F(head, FoldR(tail, F, U))
end

function Plus(x, y)
    return x+y
end

function Mul(x, y)
    return x*y
end

println(FoldR([1,5,3,7,9], Plus, 0))
println(FoldR([1,5,3,7,9], Mul, 1))
```
Функция FoldR обобщила исходный код суммирования до универсального: она получает в дополнение к списку саму операцию (функцию F) и нейтральный элемент U, и теперь мы можем использовать её для всех похожих ассоциативных вычислений (когда порядок аргументов функции F не важен для её результата).

FoldR -- функция с таким названием существует во многих языках функционального программирования. Это функция-свёртка, а буква R в её конце означает правую ассоциацию – схема её вызовов развёртывается в цепочку, пока не будет достигнуто самое крайнее (правое) значение в списке, после чего начнутся непосредственные вычисления.

FoldR часто используется для универсальной обработки списков. Например, создадим функцию, которая возвращает true, если хотя бы один элемент списка – true.
```
function tru(x, y)
    return x || y
end

function Some(L)
    return FoldR(L, tru, false)
end

println(Some([false,false,false,true]))
```
FoldR – это пример абстракции цикла (рассматривается далее).

