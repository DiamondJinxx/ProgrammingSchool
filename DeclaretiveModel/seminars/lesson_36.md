# 36. Свёртка списка и дополнительные способы поддержки циклов

Существует ещё одна схема цикла с аккумулятором для списка. Свёртка (folding) фактически означает, что мы "вставляем" операцию между значениями списка:

"+" [1,2,3] = 1 + 2 + 3

Способ вычисления такой конструкции отдаётся компилятору, что позволяет достигать хорошей производительности -- например, за счёт распараллеливания.

В языках программирования, в том числе и декларативных, могут реализовываться самые разные лингвистические способы поддержки циклов. Классическая запись цикла
for заголовок тело
по сути эквивалентна схеме, когда тело выделяется в отдельную процедуру, и она многократно вызывается, получая в качестве параметра счётчик цикла.

Однако имеется фундаментальное различие между декларативным и императивным определениями циклов. В последнем случае счетчик циклов -- изменяемая переменная, которой присваивается разное значение для каждой итерации. Декларативный цикл совершенно другой: на каждой итерации он фактически объявляет новую переменную, хотя обращение к ней происходит по одному и тому же идентификатору. Такая разница даёт серьёзные последствия.

В частности, итерации декларативного цикла полностью независимы от друг друга -- таким образом, их можно выполнять одновременно, не меняя окончательный результат работы цикла. А так как никаких состояний в смысле классических переменных в декларативной модели нету, то и не возникают типовые проблемы конкуренции, которые мы изучали на первом курсе по парадигмам программирования.

А вот сделать так в императивном цикле практически невозможно: внутри каждой итерации больше нельзя быть уверенным, что она получает доступ к правильному значению счётчика цикла, если попытаться выполнять все итерации одновременно.

Аналогично во многих языках программирования имеется синтаксическая версия итерации по спискам -- например, цикл foreach, а что касается свёртки списка, то в стандартные библиотеки часто включаются функции map/reduce, выполняющие вычисления по свёртке и foldL/R.

В декларативной схеме цикла возможны конечно ещё многие другие дополнительные расширения. Например: немедленный выход из цикла (break), немедленный выход и возврат явного результата (return), немедленное выполнение следующей итерации (continue), итераторы по спискам наподобие foreach, и другие процедуры, "подразумевающие" цикл (нахождение суммы элементов списка, максимальное значение в списке и т. п.).


# Программирование, управляемое данными (Data-driven)

Частой и даже универсальной задачей считается выполнение некоторой операции над структурой данных (на практике достаточно большой), итерация или обход этой структуры и вычисление некоторой другой структуры данных на основе такого обхода.
Эта схема чаще всего применяется к спискам и деревьям. Для списков обычно применяются операции FoldR и FoldL, есть и другие типовые техники.

Классическая универсальная операция над списками – это Map, которая вычисляет новый список такого же размера, как и исходный, применяя заданную функцию к каждому его элементу. Реализация Map имеется практически во всех популярных языках программирования, в Julia например она называется map().

Допустим, мы хотим округлить с помощью функции round() все значения в списке:

```
map(round, [1.2, 3.5, 1.7]) # [1.0, 4.0, 2.0]
```