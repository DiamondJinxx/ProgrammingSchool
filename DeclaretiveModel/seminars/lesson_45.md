# 45. Методология проектирования в малом/in small

Возникла ситуация, когда требуется в одиночку разработать относительно небольшую программу (ориентировочный объём – до единичных десятков тысяч строк). Рекомендуется следующая простая методика проектирования, в которой смешаны творческий подход и формальное мышление:

1) Неформальная спецификация. Мы начинаем с того, что записываем как можно точнее, что должна делать программа: что она будет получать на вход, что должна выдавать на выходе, и каким образом выходные данные соотносятся с входными. Такое описание называется неформальная спецификация (в мэйнстриме она часто называется техническим заданием). Несмотря на то, что она будет, как мы рассчитываем, точна как только можно, мы называем ее "неформальной", потому что она будет написана на обычном русском языке. "Формальные" спецификации записываются в математической нотации.

2) Примеры. Чтобы ещё больше прояснить спецификацию, всегда хорошо и полезно представить примеры того, что делает программа в конкретных случаях (лучше всего в формате тестов). Эти примеры должны, во-первых, показывать «границы» программы (проверять её работу в граничных условиях и самыми неожиданными способами, которые мы можем себе представить), и во-вторых, демонстрировать типовые сценарии её эксплуатации.

3) Исследование. Чтобы выяснить, какие конкретно методы программирования нам подойдут лучше всего, хороший способ -- использовать интерактивный интерфейс для экспериментов с фрагментами программы. Идея состоит в том, чтобы написать небольшие достаточно автономные операции, которые, как мы думаем, буду необходимы нашей программе. Эти операции достаточно наглядны и обеспечивают некоторый системный базис программы. Этот шаг дает нам более чёткое представление о том, что представляет собой структура нашей программы.

4) Структура и реализация. Теперь мы можем сформировать структуру программы: делаем приблизительный набросок операций, необходимых для расчета результатов, получаемых на входе, и способы, которыми эти операции будут комбинироваться друг с другом. Затем мы заполняем оставшиеся пробелы, добавляя реальный код. Операции должны быть простыми: каждая операция должна делать только одну вещь. Для улучшения структуры мы группируем связанные операции в модули.

5) Тестирование и обдумывание. Наконец, мы должны убедиться, что наша программа работает правильно. Мы проверяем её на серии тестовых случаев, включая примеры, которые мы придумали раньше. Мы исправляем ошибки до тех пор, пока программа не заработает хорошо. Мы также можем порассуждать о структуре программы и о её сложности, используя формальную семантику для непонятных частей. Тестирование и обдумывание взаимодополняемы: важно делать и то, и другое, чтобы получить качественную программу.

Как видите, подход программирования в малом весьма простой. Перечисленные шаги не являются обязательными, они скорее служат вдохновляющей схемой для разработчика. Не стесняйтесь адаптировать их к своим конкретным обстоятельствам. Например, на любом шаге может появиться понимание того, что надо внести определённые коррективы в предыдущие шаги, в частности, в спецификацию. Пока разработчик один, код пишется аккуратно и его не очень много, такие итерации не вызывают особых проблем. Однако, никогда не забывайте о самом важном шаге в процессе programming in small -- тестировании. В частности, полезно сразу применять какую-нибудь конкретную методику, тесно связанную с тестами, например, TDD.

# # Пример подхода programming in small

Имеется простое рабочее задание для программиста-стажёра:

Напишите функцию, которая получает в качестве аргумента имя файла, содержащего текст книги, и затем выводит на экран список пар, где каждая пара состоит из слова и целого числа, показывающего количество раз, сколько это слово встречается в файле.

Достаточно ли точна эта спецификация? Надо ли выводить результат в отсортированном порядке? В каком именно? Что понимается под "словом", как слова отделяются друг от друга? Надо ли учитывать разные кодировки (не ASCII), надо ли учитывать в качестве разделителей знаки препинания, или символы табуляции? Что, если файл в двоичном формате? Что должно быть выведено, если файл пустой или сбойный?

Мы обращаемся к заказчику (или старшему программисту), который нехотя уточняет: считайте словом непрерывную последовательность из английских букв и цифр (хотя, скорее всего, понадобится также учитывать и дефис, и символ подчёркивания).

В данной ситуации хорошо помогли бы примеры, но, как часто бывает, их нету.

Хорошо, следующий шаг -- проектирование структуры программы, как минимум, предварительное обдумывание её в уме, абсолютно обязательно -- физически не перед экраном компьютера. Применим схему организации функций как конвейера, что мы делали при создании декларативного стека: сначала функция читает файл в виде списка символов, затем преобразовывает список символов в список слов.

Важный момент, что восприятие файла как списка строк – слабая абстракция, так как каждую строку придётся вводить и обрабатывать отдельно, что добавляет ненужную сложность. Правильнее воспринимать файл как непрерывный поток символов.

По мере того, как последовательно выделяются слова, надо накапливать по ним статистику. Для этого нужна структура данных, которая позволяет использовать слова как индексы или ключи – стандартный словарь хорошо подойдёт.

Далее мы делаем тесты, готовим несколько файлов с тестовыми данными, статистика по словам которых собрана вручную, и особо проверяем непонятные или нечёткие случаи, чтобы в случае чего быстро их исправить и проверить.

Такая схема в общем и целом близка практической работе программиста над небольшими проектами. В ней нету никаких сложных моментов, главное:
- обеспечивать адекватность спецификации, не допуская по возможности неоднозначных мест, которые потом могут серьёзно усложнить доработку,
- сохранять ясность и выразительность кода, чтобы он был легко понятен и самому разработчику, и другим людям,
- поддерживать хорошее множество тестов, покрывающих как спецификацию (словесное описание задания), так и реализацию (код).