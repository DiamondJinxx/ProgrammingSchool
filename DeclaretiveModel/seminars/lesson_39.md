# 39. Fold/Reduce

Как уже отмечалось, FoldR и FoldL (свёртка folding в мэйнстриме часто называется reduce) работают как цикл for с аккумулятором, однако мы можем выразить его через универсальный итератор Iterate, который мы изучали ранее:
```
function Iterate(S, IsDone, Transform)
  if IsDone(S)
     return S
  end 

  S = Transform(S)
  return Iterate(S, IsDone, Transform) 
end

function is_done(Ls)
  return length(Ls) == 1
end

function transform(Ls)
  S1 = [Ls[1] * Ls[2]; Ls[3:end]] 
  return S1 
end

function FoldL(Ls, F, U)
    if Ls == []
       return []
    end
    if is_done(Ls)
       return Ls[1]
    end

    return Iterate(Ls, is_done, F)
end

println(FoldL([1,5,3,7,9], transform, 1))
```
На самом деле, Iterate -- это универсальная абстракция while-цикла с аккумулятором. Все абстракции цикла могут быть выражены через этот итератор.



# Деревья

Общая операция для дерева, как упоминалось выше – это обход всех его узлов в некотором заданном порядке, и выполнение некоторой операции над каждым узлом (в частности, при его посещении во время обхода). Например, если это абстрактное синтаксическое дерево, то при его обходе можно сразу генерировать результирующий программный код.

Стандартная процедура обхода дерева DFS (depth-first search) очень проста: находясь в некотором узле, мы последовательно вызываем DFS для каждого из его дочерних узлов. Сама по себе она не очень полезна, так как ничего не вычисляет. Можно например её использовать для вывода дерева на печать, но для какого-то реального применения потребуется версия DFS с аккумулятором.

В таком случае появятся три версии DFS:
– сверху вниз (результат накапливается по мере движения от родительских узлов к дочерним, это по сути FoldL),
- снизу вверх (результат накапливается при подъеме от дочерних узлов, когда мы рекурсивно спустились к ним, обратно к родителям, это по сути FoldR),
- или в каком-то другом порядке (например, по уровням дерева).

