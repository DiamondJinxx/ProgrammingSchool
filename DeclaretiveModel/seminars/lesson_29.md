# 29. Эффективность по времени и памяти
Декларативное программирование -- это прежде всего программирование. Несмотря на то, что оно обладает сильными математическими свойствами, результатом его получаются всё те же реальные программы, которые работают на реальных компьютерах. Поэтому и тут важно думать о вычислительной эффективности (время и память). Эта тема затрагивалась на курсах по алгоритмам и структурам данных, где мы ориентировались на О-большое (наихудший случай).

На практике, из-за того, что программы работают на всё усложняющемся железе и используют весьма сложные возможности стандартных библиотек языка и операционной системы, виртуальные модели памяти и т. п., определить реальную производительность и требуемые ресурсы алгоритма без его привязки к контексту исполнения в общем случае становится почти невозможно. Поэтому применяется также амортизационный анализ (когда мы учитываем, что шагами алгоритма могут быть как "лёгкие" операции, так и весьма нагрузочные).

Декларативная модель в алгоритмическом плане -- одна из самых простых, поэтому оценивать эффективность декларативных алгоритмов достаточно легко. В частности, надо активно учитывать распространённость рекурсии, которая, как было показано, довольно часто на практике, при слабой реализации, требует существенных ресурсов по памяти (стек). Но прикладная (не математическая) оптимизация по памяти обычно выполняется значительно проще, нежели оптимизация по производительности.

Во-первых, в декларативной модели сам алгоритм, как мы видели, легче и по известным схемам переписывается в более экономный вид;

во-вторых, под очень многие задачи можно подобрать простую, экономную и хорошо изученную структуру данных (прежде всего из рассмотренных выше);

в-третьих, саму память можно оптимизировать, например, с помощью сборщиков мусора и алгоритмов сжатия, и т. д.

Однако оптимизированный код никогда не бывает "оптимальным" ни в каком математическом смысле. Обычно программа может быть легко улучшена, но лишь до некоторой точки, после чего отдача от её улучшений начинает уменьшаться, а сама программа быстро усложняется, и последующие улучшения дают ещё меньший эффект. Поэтому оптимизация не должна выполняться, если в ней нет явной необходимости.

Оптимизация имеет как хорошую, так и плохую сторону. Хорошая сторона в том, что в целом время выполнения большинства приложений в значительной степени определяется работой очень малой части кода программы. Поэтому оптимизация производительности при реальной необходимости почти всегда может быть ограничена переписыванием только этой маленькой части (иногда буквально нескольких строк).

Плохая сторона в том, что обычно не очевидно даже опытным программистам, где эта часть априори находится. Поэтому эта часть сперва должна быть идентифицирована в процессе работы программы -- как правило, с помощью технологии профилирования.

Оптимизировать (сократить) использование программой оперативной памяти обычно заметно проще, нежели сократить время её выполнения. Если память -- это критическая проблема, то хорошим приёмом будет использование алгоритмов сжатия данных, которые не участвуют в основных вычислениях. Тут придётся искать баланс между экономией пространства и повышением быстродействия.


# Программирование высшего порядка
Программирование высшего порядка представляет собой набор методов программирования, которые становятся доступными при использовании значений процедур в программах. Под значениями процедур понимается, во-первых, наличие в системе типа данных "процедура", и соответственно, во-вторых, любая реальная процедура, определённая в программе, автоматически становится значением (как число, строка, список), которое можно передавать в другие процедуры в качестве аргумента, или получать в качестве результата их работы.

Как правило, программирование высшего порядка связано с понятием лексического замыкания, когда функция существует в программе как объект и может обращаться к внешнему контенту (например, локальным переменным в текущем блоке).

Термин "высший порядок" происходит от концепции порядка процедуры. Процедура, все аргументы которой не являются процедурами, имеет нулевой порядок. Процедура, имеющая в аргументах хотя бы одну процедуру нулевого порядка, считается процедурой первого порядка.

И так далее: процедура имеет порядок n + 1, если у неё есть, по крайней мере, один аргумент порядка n и ни одного аргумента более высокого порядка.

По сути, программирование высшего порядка означает просто, что процедуры теперь могут быть любого порядка, а не только нулевого.


Существуют четыре основные операции, которые лежат в основе всех техник программирования высшего порядка:

1) Процедурная абстракция: способность преобразовывать любую программную логику в значение процедуры.

2) Обобщение (Genericity): возможность передавать значения процедур в качестве аргументов при вызове другой процедуры.

3) Инстанцирование: возможность возврата процедурного значения как результата вызова процедуры.

4) Встраивание: возможность помещать значения процедур в структуры данных.

