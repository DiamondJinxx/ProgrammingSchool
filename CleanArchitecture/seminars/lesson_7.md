# 7. Околофункциональная архитектура
Строго говоря, в предыдущем примере мы наивно и безсистемно перемешали объектную архитектуру с функциональным движком.

То есть чистая серверная логика реализована в функциональном стиле (основные функции вынесены в отдельный модуль pure_robot.py), а состояние хранится в обособленной объектной прослойке CleanerApi, непосредственно поддерживающей API. Вся логика работы с состоянием перенесена на промежуточный уровень middleware, в класс CleanerApi.

Такая конструкция известна как Functional Core / Imperative Shell.

В эту схему в принципе можно добавить куда больше "функциональщины": например, правильнее сделать так, чтобы независимо от корректности обработки входных данных API всегда возвращал единый объект некоторого типа Result. Такой тип уже в самом себе будет включать, например, признак ошибки -- в случае, если входная команда от клиента парсится неправильно. Соответственно, и конкретные функции (move, turn, ...) надо, как выражаются прикладные математики, "обернуть в монады": чтобы все они работали с входными и выходными данными единого типа Result. В функциональных языках для этого имеются специальные механизмы; мы рассмотрим такой подход отдельно.

Плюсы.

В дополнение ко всем преимуществам чистого объектного подхода мы дополнительно выделили чистое функциональное ядро, которое никак не связано с изменяемыми состояниями. Его реализацию можно изменять без затрагивания промежуточного слоя. Вся мутабельная часть явно отделена от иммутабельной, что существенно упрощает тестирование всей системы.

Минусы.

По-прежнему мы остаёмся зависимыми от конкретной реализации функционального ядра, функции которого вызываются в middleware-слое напрямую.

Далее мы рассмотрим, как создать "stateless" архитектуру -- простую, но хорошо масштабирующуюся горизонтально.

