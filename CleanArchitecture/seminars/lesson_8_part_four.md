# Stateless-архитектура

Вся внутренняя "кухня" работает с единым типом RobotCommand, определяющим сообщение, находящееся в очереди и исполняемое агентом. В этом классе хранится исходное (текущее) состояние робота и команда на его изменение.

Отмечу, что модуль pure_robot.py из предыдущих примеров -- ключевая библиотека логики в формате чистых функций, перекочевала в данную новую версию системы без каких-либо изменений. Это отличный пример практичности функционального подхода.

В Python имеется стандартный класс Queue, который позволяет организовать мультитредовую асинхронную обработку очереди.
В нашем примере будут две очереди:
- первая входная, куда серверные обработчики клиентских запросов на выполнение команд роботу будут складывать эти запросы, и
- вторая выходная, которую сервер непрерывно опрашивает и при появлении ответа сразу передаёт его обратно соответствующему клиенту. Мы намеренно не касаемся технических деталей идентификации связи ответа и клиента; это достаточно прозрачно реализуется добавлением поля - уникального идентификатора в класс RobotCommand.

Код
```
num_workers = 5
for i in range(num_workers):
    t = ThreadRobo(queue, out_queue)
    t.setDaemon(True)
    t.start()
```
подразумевается, инициализируется сервером в момент выполнения. Мы задаём в константе num_workers количество воркеров, которые в параллельном многопоточном режиме ожидают появления запросов во входной очереди, тем самым регулируется горизонтальная мощность нашей серверной части.
Класс ThreadRobo задаёт структуру воркера. В бесконечном цикле он выбирает некоторый доступный запрос из очереди (если очередь пуста, ожидание входного запроса не нагружает процессор), далее с помощью функциональной библиотеки выполняет обработку, после чего возвращает результат в выходную очередь, информируя входной поток о завершении обработки исходного сообщения.

Взаимодействие с клиентской частью происходит через функцию command_to_queue. Она помещает входной запрос в очередь, ожидает его обработки, помечает обработку выполненной, после чего возвращает результат клиенту. Эта функция конечно условна -- в реальной системе вместо одной такой функции будут две. Первая поместит запрос в очередь, записав в него идентификатор клиентской сессии, а вторая, получив из выходной очереди результат, по сохранённому в нём идентификатору отправит ответ соответствующему клиенту.

Клиентская часть совсем прозрачна. Всё взаимодействие умещается фактически в две инструкции -- формирование запроса и вызов command_to_queue.

Для проверки эффективности нашей мультиагентной системы заставим робот вращаться на месте подачей тысячи соответствующих команд: можно измерить время обработки на сервере и распределение быстро поступающих запросов воркерам.

