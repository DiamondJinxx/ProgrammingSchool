# 6. Реализация объектной системы
Как уже отмечалось, ООП желательно использовать в основном при наличии явной необходимости в наследовании, и достаточно ограниченно; в остальных случаях лучше придерживаться декларативной/функциональной моделей.

Как правильно и легко реализовать полноценную объектно-ориентированную систему на основе декларативной модели вычислений, расширенной явным состоянием? Это делается в основном сочетанием программирования высшего порядка с явным состоянием -- через это сочетание вы полностью поймёте концепцию объектов и классов.

Первый шаг в понимании того, как построить систему объектов, заключается в том, чтобы понять, как связаны между собой её различные части.
ООП задаёт иерархию абстракций, которые связаны друг с другом своего рода отношениями "спецификация-реализация". Существует множество вариантов этой иерархии, рассмотрим простую схему, набор абстракций, от более конкретных к более абстрактным:

- Работающий объект -- это активное обращение к объекту, связывающее поток исполнения программы с объектом. Работающий объект содержит набор элементов окружения (например, часть стека, которая создаётся во время "выполнения" объекта), а также сам объект.

- Объект -- это процедура, которая инкапсулирует явное состояние (ячейку) и набор процедур, которые ссылаются на это состояние.

- Класс - это обёртка записи, в которую заключён набор процедур и набор атрибутов. Эти процедуры называются методы. Методы получают состояние атрибутов в качестве параметра, и изменяют это состояние. Методы могут вызывать друг друга.
Часто бывает полезно следующее различие:
- Абстрактный класс -- это класс, в котором некоторые методы не имеют определения.
- (Конкретный) класс -- это класс, в котором определены все методы, которые вызываются в программе.

Если язык поддерживает сообщения первого класса, то возможны вызовы вида

Obj Msg 
где Msg вычисляется непосредственно во время выполнения.
Если такой "вызов" Msg в программе явно присутствует, то различие между абстрактным и конкретным классом исчезает (хотя оно может существовать концептуально). Выполнение вызова "Obj Msg" вызывает исключение, если Msg не существует в Obj. Но большинство современных языков со статической типизацией такую возможность вычисления сообщения (метода) на лету не допускают -- возникнет ошибка компиляции.
- Метакласс -- это класс с определённым набором методов, которые соответствуют основным операциям, характерным именно для класса, а не для объекта, например: создание объекта, политика наследования (как методы наследовать), вызов метода, возврат из метода, выбор метода для вызова, присвоение атрибутов, доступ к атрибутам, вызов self/this и т. п.
Реализация этих методов позволяет настраивать семантику объектов в вашей системе.


## Как все эти сущности связаны друг с другом

Работающий объект создаётся, когда в потоке выполнения программы встречается обращение к некоторому объекту. Работающий объект существует до тех пор, пока поток его не "отпустит" (не закончит взаимодействие с основным объектом). Несколько "вызовов" одного и того же физического объекта вполне могут "существовать" в программе одновременно в виде нескольких рабочих объектов, если она поддерживает параллельную модель вычислений.

Объект создаётся как экземпляр класса. Если объектная система делает различие между абстрактными и конкретными классами, то обычно допускается создавать только экземпляры конкретных классов. Объект как абстрактная сущность существует в программе вечно и инкапсулирует ячейку, которая была создана специально для него.
На практике, объект обычно существует до тех пор, пока активно работающая программа не потеряет все ссылки на него. В этот момент сборщик мусора может освободить память, отведённую под объект, а финализация (условный деструктор) может выполнить последнее действие, если это необходимо. Несколько экземпляров одного и того же класса могут существовать в программе одновременно.

Класс создаётся через наследование от списка других классов. Новый класс существует вечно. Наследование получает множество существующих методов и список существующих классов, и возвращает новый класс с новым набором методов. Несколько классов, которые наследуются от одного и того же класса, могут существовать одновременно. Если класс может наследоваться от нескольких классов, то мы имеем множественное наследование, а если класс может наследоваться только от одного класса, то мы имеем единичное наследование.

Класс может быть создан как экземпляр метакласса. Новый класс существует вечно. Основные операции такого класса определяются конкретными методами метакласса. Несколько экземпляров одного и того же метакласса могут существовать одновременно.

## Реализация классов
Рассмотрим лингвистическую абстракцию класса. Класс -- это просто значение, запись, которая защищена от доступа за счёт обёртки, как мы рассматривали ранее.

Запись класса содержит:
- набор методов (в виде условной "таблицы", или списка методов). Каждый метод - это процедура с тремя параметрами:
сообщение M (которое всегда является записью),
дополнительный параметр S (состояние текущего объекта), и
Self (ссылка на сам объект).
- набор имён атрибутов, задающих атрибуты, которыми будет обладать каждый экземпляр класса (объект). Каждый атрибут представляет собой ячейку с состоянием, доступ к которой осуществляется с помощью имени атрибута.

На практике эта схема дополняется различной технической спецификой, например статическим связыванием методов с Self.

## Реализация объектов
Существует универсальная функция New, которая создает объект из любого класса. Она начинается с разворачивания записи класса из её обёртки. Затем создаётся состояние объекта (запись) из атрибутов класса, и перебором всех полей записи каждое поле инициализируется ячейкой с несвязанным начальным значением.

Объект Obj, возвращаемый функцией New -- это процедура с одним параметром. Например, вызов

Obj M (передача сообщения M объекту Obj)
или, в обычном объектном синтаксисе,
Obj.M
вызывает процедуру Obj с параметром M, которая отыскивает нужный метод, соответствующий M, в таблице методов. Вследствие лексического замыкания состояние Obj доступно только внутри Obj. По сути, Obj -- это процедура с инкапсулированным состоянием.
Но это формальное описание, на практике такая схема обычно существенно оптимизирована или вообще реализована по другому: как правило, обращения к объектам (вызовы их методов) так же эффективны, как и вызовы обычных функций.

## Реализация наследования
Наследование "вычисляет" новую запись класса, используя существующие записи классов, которые объединяются в соответствии с правилами наследования. Это определение немного упрощено, потому что оно не учитывает статическое связывание.

