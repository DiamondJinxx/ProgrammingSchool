# 5. Связь ООП с другими вычислительными моделями
ООП -- это один из способов структурирования программ, который чаще всего применяется вместе с явным состоянием. В сравнении с другими вычислительными моделями ООП характеризуется, прежде всего, использованием наследования.

Наследование, строго говоря -- отнюдь не новая концепция, оно рождается скорее из способа определения лингвистической абстракции классов, и на самом деле, довольно тесно связано с разными техниками программирования высшего порядка.

Объектно-базированное программирование -- это ООП без наследования. Оно по сути представляет собой компонентно-базированное программирование, расширенное синтаксической поддержкой классов. Без наследования объектная абстракция становится намного проще и предлагает удобную нотацию для инкапсуляции состояния и определения множества операций над ним (исчезают проблемы с переопределением методов, пропадает различие между статическим и динамическим связыванием, и т. п.).

Программирование высшего порядка тесно связано с ООП. Допустим, имеется функция сортировки, которая получает на вход функцию, сравнивающую два элемента, и возвращает итоговую функцию, "параметризованную" конкретной функцией сравнения (например, под конкретный тип данных). В объектно-базированном программировании (без наследования) мы можем создать класс сортировки, который будет получать в конструкторе или параметром отдельного метода объект другого класса (композиция), который выполняет сравнение значений конкретных типов. В ООП (с наследованием) создаются классы-потомки, которые перезаписывают метод сравнения значений "абстрактного" типа сравнением значений конкретного типа.

# Вкусняшки, добавляемые ООП
Очевидно, что процедурные/функциональные значения и объекты тесно связаны. Основная разница между программированием высшего порядка и ООП заключается в том, что ООП как бы "приукрашивает" программирование высшего порядка -- и семантически, и синтаксически. Это более богатая абстракция, предоставляющая набор дополнительных идиом за рамками процедурной абстракции.

- Явное состояние легко определяется и используется.
- Легко определяются множественные методы, обрабатывающие одно и то же явное состояние, а объект выбирает нужный метод для вызова.
- Доступны классы, которые задают набор методов, а на их основе создаются объекты, причём каждый экземпляр класса имеет оригинальное явное состояние. Если объекты подобны обычным процедурам, то классы подобны процедурам высшего порядка, которые возвращают "процедуры" (объекты) в качестве своего значения.
- Предусмотрено наследование, позволяющее определять новые наборы методов на базе существующих наборов -- путём расширения, модификации и комбинирования существующих методов. Статическое и динамическое связывание делают эту возможность особенно богатой.
- На уровне классов и объектов могут быть определены различные уровни инкапсуляции. Атрибуты и методы могут быть private/public/protected, или иметь какую-либо другую степень инкапсуляции, определяемую программистом.

Важно отметить, что все эти механизмы ООП не предоставляют никаких принципиально новых возможностей. Они могут быть полностью определены с помощью программирования высшего порядка, явного состояния и имён-как-значений (для поддержки разных схем видимости). С другой стороны, эти механизмы оказываются весьма полезными идиомами, которые приводят к удобному стилю программирования.

ООП -- это абстракция, которая предоставляет выразительную синтаксическую нотацию для использования любого из этих механизмов, или всех вместе, когда они необходимы. Но такое богатство -- обоюдоострый меч. С одной стороны, оно делает абстракции действительно полезными во множестве прикладных задач программирования. С другой стороны, абстракция ООП характеризуется довольно сложной семантикой, и о системе в парадигме ООП на самом деле трудно рассуждать, как только проект становится более-менее объёмным. Работая с ООП, можно быстро насоздавать в проекте много "сложностей", и выдерживать на практике принцип "сложность системы равна линейной сумме сложностей её подсистем" становится практически невозможным.

По этой причине, как ни странно это прозвучит в контексте применения научных парадигм программирования к повседневной разработке, рекомендуется всё же использовать ООП только в тех случаях, когда оно значительно упрощает структуру программы. Например, когда есть явная необходимость в наследовании: программа содержит набор тесно связанных абстрактных типов данных, каждый из которых представляет собой частичное расширение или уточнение родительского АТД. В остальных случаях предлагается применять более простые методы и приёмы программирования, прежде всего декларативные.

## Общие ограничения объектного подхода
Парадигма cистемы объектов с наследованием, определенная на данном курсе, особенно близка к программированию высшего порядка. Не все объектные системы так к нему близки.

На практике, ряд нижеприведённых полезных характеристик системы объектов, близкой к программированию высшего порядка, часто отсутствует или неудобен в использовании:
- Классы как значения. Классы (фактически, пользовательские типы данных) можно создавать во время выполнения, передавать в качестве аргументов, и хранить в структурах данных.
- Полное лексическое замыкание. Подразумевается, что язык программирования поддерживает процедурные значения с внешними ссылками. Это позволяет определить класс внутри области видимости процедуры или другого класса. В Java например такой подход предлагается с некоторыми ограничениями: допускаются вложенные классы.
- Сообщения первого класса. Обычно имена сообщений и методов должны быть известны во время компиляции. Самый общий способ снять это ограничение -- позволить сообщениям быть значениями, которые могут вычисляться во время выполнения. В некоторых популярных языках предоставляется такая возможность, хотя она синтаксически обычно более многословна, чем статические вызовы методов.
В целом, многие популярные объектно-ориентированные языки, например, C++, не поддерживают полноценное программирование высшего порядка, поскольку они не допускают процедурные значения с лексическим замыканием во время выполнения. Но в этих языках многие возможности программирования высшего порядка могут быть получены с помощью инкапсуляции и наследования, с небольшими дополнительными усилиями со стороны программиста.
- Процедурное значение может быть представлено как объект. Атрибуты объекта представляют собой внешние ссылки процедурного значения, а параметры метода -- это параметры процедурного значения. Когда объект создается, его атрибуты инициализируются значениями по внешним ссылкам. Объект можно передавать и вызывать точно так же, как и процедурное значение. При соблюдении простой дисциплины и получается программирование с процедурными значениями, что в свою очередь допускает возможность программирования высшего порядка.
- Общая/обобщённая процедура может быть закодирована как абстрактный класс. Общая процедура -- это процедура, которая принимает аргументы и возвращает конкретную процедуру. Например, общая процедура сортировки может принимать операцию сравнения для заданного типа и возвращает готовую процедуру сортировки, которая сортирует массивы соответствующего типа. А в случае абстрактного класса неопределённые в нём методы конкретизируются в классах-наследниках.

В результате мы можем использовать почти все приемы программирования высшего порядка, описанные в этом курсе. Но у объектно-ориентированного подхода есть два недостатка по сравнению с процедурным: он более громоздкий в написании, и в объекте-замыкании внешние ссылки должны быть указаны в явном виде.

# Декомпозиция в ходе проектирования
Довольно принципиальный момент, вызывающий и по сей день множество споров -- применять ли функциональную декомпозицию в ходе проектирования, или декомпозицию типов (например, в виде иерархии классов)? Точнее, в каких случаях какой подход будет более продуктивным?

Пусть имеется АТД, базирующийся на родительском типе T, и имеющий подтипы T1, T2, T3 и набор операций F1,...,Fn. Как лучше его организовать в программе?

В декларативной парадигме мы конструируем функции, следуя определениям типов. В ООП мы конструируем иерархии типов, тоже по сути следуя определениям типов.

Однако в результате мы получаем программы, сильно различающиеся по структуре -- будем называть эти структуры результатом функциональной декомпозиции, или декомпозиции типов.

В функциональной декомпозиции каждое определение функции целостно само по себе, но сами типы "размазаны" по всем функциям. В декомпозиции типов каждое определение типа целостно само по себе, но сами функции "размазаны" по всем типам. Что выбрать?

При функциональной декомпозиции можно изменить существующую функцию или добавить новую функцию без изменения определений других функций. Однако изменение существующего типа или добавление нового типа потребует изменения всех или большинства определений функций.

При декомпозиции типов можно изменить существующий тип (класс), или добавить новый тип (например, с помощью наследования) без изменения других определений типов. Однако изменение существующей функции или добавление новой функции потребует изменения определений всех или большинства классов.

Перед разработкой программы полезно спросить себя, какой вариант из этих двух выглядит наиболее подходящим. Если система типов в программе относительно проста, и подразумевается большое количество операций над типами, то лучше выбрать функциональную декомпозицию.

Если же система типов сложная (напрашивается иерархия), и с относительно небольшим количеством операций, то подход через декомпозицию типов может быть более ясным.


# Декомпозиция в ходе проектирования
Довольно принципиальный момент, вызывающий и по сей день множество споров -- применять ли функциональную декомпозицию в ходе проектирования, или декомпозицию типов (например, в виде иерархии классов)? Точнее, в каких случаях какой подход будет более продуктивным?

Пусть имеется АТД, базирующийся на родительском типе T, и имеющий подтипы T1, T2, T3 и набор операций F1,...,Fn. Как лучше его организовать в программе?

В декларативной парадигме мы конструируем функции, следуя определениям типов. В ООП мы конструируем иерархии типов, тоже по сути следуя определениям типов.

Однако в результате мы получаем программы, сильно различающиеся по структуре -- будем называть эти структуры результатом функциональной декомпозиции, или декомпозиции типов.

В функциональной декомпозиции каждое определение функции целостно само по себе, но сами типы "размазаны" по всем функциям. В декомпозиции типов каждое определение типа целостно само по себе, но сами функции "размазаны" по всем типам. Что выбрать?

При функциональной декомпозиции можно изменить существующую функцию или добавить новую функцию без изменения определений других функций. Однако изменение существующего типа или добавление нового типа потребует изменения всех или большинства определений функций.

При декомпозиции типов можно изменить существующий тип (класс), или добавить новый тип (например, с помощью наследования) без изменения других определений типов. Однако изменение существующей функции или добавление новой функции потребует изменения определений всех или большинства классов.

Перед разработкой программы полезно спросить себя, какой вариант из этих двух выглядит наиболее подходящим. Если система типов в программе относительно проста, и подразумевается большое количество операций над типами, то лучше выбрать функциональную декомпозицию.

Если же система типов сложная (напрашивается иерархия), и с относительно небольшим количеством операций, то подход через декомпозицию типов может быть более ясным.

# Правильно ли считать всё объектом? Сильные объекты.
Сторонники ООП часто провозглашают принцип "всё должно быть объектом", однако обычно без точного определения, что именно он должен означать.

Разумно определить этот принцип так: "все языковые сущности должны быть экземплярами АТД с (по возможности) максимально общими свойствами".
В своей крайней форме он подразумевает пять характеристик:
- все языковые сущности должны задаваться классами;
- все языковые сущности должны быть расширяемыми с помощью наследования;
- все языковые сущности должны уникально идентифицироваться;
- все языковые сущности должны инкапсулировать состояние;
- доступ ко всем языковым сущностям должен осуществляться с помощью единого синтаксиса.

Иногда для определения сущностей со всеми этими свойствами используется слово "объект". Чтобы избежать путаницы, будем называть их сильные объекты.

Объектно-ориентированный язык называется чистым (pure), если все его сущности -- сильные объекты.

Стремление к чистоте языка даёт ряд полезных вещей. Например, во многих языках есть понятие "исключения" для обработки аномальных событий во время выполнения, и будет очень удобно, если исключения оказываются объектами в иерархии наследования. Это позволяет легко классифицировать их по различным категориям, ловить их, только если они относятся к определенному классу (или его подклассам), и, возможно, изменять их (добавлять информацию), если они поддерживают состояние.

Практически не существует пока популярных языков, в которых бы все сущности были сильными объектами. Например, целые числа в Java (не Integer, а int) -- это чистые значения; они не определены классом и не инкапсулируют состояние. Объект в Java может иметь атрибуты с характеристикой final, что не позволяет их изменять и означает, что объект не имеет состояния. Массив в Java не может быть расширен с помощью наследования, а сами они ведут себя так, как если бы они были определены с final, и т. д.

Но должен ли язык (или система типов в проекте) вообще поддерживать только сильные объекты? Ответ -- нет, по многим причинам.

Во-первых, важную роль могут играть объекты без состояния -- с ними становятся возможны мощные методы из декларативного программирования. Именно по этой причине многие языки допускают их использование. Кроме того, сущности без состояния необходимы для того, чтобы сделать прозрачным проектирование распределенных систем.

Во-вторых, не все сущности нуждаются в уникальной идентичности. Например, явно структурированные сущности (кортежи в базе данных) идентифицируются по их содержимому, а не по именам.

В-третьих, вроде бы напрашивающаяся простота единообразного синтаксиса в случае сильных объектов оказывается на практике иллюзорной.

В итоге у нас остались две характеристики из пяти:
- все сущности языка должны быть экземплярами АТД, и
- синтаксическое единообразие при работе с АТД должно использоваться, когда это целесообразно.
Одни АТД будут обладать всеми свойствами сильных объектов; другие -- только некоторыми из этих свойств, но также и некоторыми другими, совершенно отличными свойствами. Эта схема хорошо согласуется с использованием множественных моделей вычислений, пропагандируемых на данных курсах.

Правильное проектирование системы заключается, прежде всего, в разработке абстракций и их реализации в виде АТД.

# Объекты и явное состояние
Подход "объекты без состояния" (stateless) считается хорошей идеей, потому что, имея в общем случае некоторый stateful-объект с явным состоянием, всегда важно понимать и уметь предсказывать в системе его будущее поведение. Оно зависит от двух факторов:
1. Внутреннее состояние объекта, которое потенциально зависит от всех прошлых обращений к нему. Эти обращения могут быть сделаны из множества самых разных частей программы.
2. Текстовое определение объекта, которое зависит от всех классов, от которых он наследуется. Эти классы могут быть определены в множестве самых разных мест в тексте программы.

Таким образом, семантика stateful-объекта оказывается распределённой во времени и пространстве, что делает объект куда более трудным для понимания, нежели функцию. Семантика функции сосредоточена в одном месте -- а именно, в её определении в коде. У функции нет истории; она зависит только от своего текстового определения и своих параметров.

Возьмём классический пример, который традиционно очень любим в computer science: реализация стандарта IEEE 754 по выполнению арифметических операций с плавающей запятой. Для него характерны определённые сложности, связанные например, с точностью вычислений, с накоплением погрешности, с реализацией на процессорах разных типов, и т. д. Рассмотрим в частности, почему объекты в подобных задачах сложнее программировать, когда у них есть состояние.

Предположим, что мы выполняем арифметические действия по стандарту IEEE 754, и что мы полностью реализовали этот стандарт: можем изменять режим округления арифметических операций во время выполнения (до ближайшего целого, округлить вверх/вниз и т.д.). Если мы будем использовать эту возможность неосторожно, то всякий раз при выполнении сложения X+Y мы не будем знать, что из этого получится, если только не проследим за всем ходом расчётов.

Любая часть программы могла изменить режим округления, что может создать полный хаос в числовых вычислениях, качество которые напрямую зависит от предсказуемого округления. Одно из решений заключается в том, чтобы все числовые методы устанавливали способ округления явно при каждом внешнем вызове, однако когда их в коде много, разобраться во всех возможных цепочках и путях вызовов практически невозможно.

Для максимального исключения подобных проблем желательно максимально усложнить в языке использование явного состояния и наследования. В отношении наследования это уже так и есть: всегда труднее использовать наследование, нежели избегать его. Что касается явного состояния, то это зависит от языка. В объектно-ориентированной модели определение функций без состояния на самом деле определённо проще, нежели определение stateful-объекта. Объекты должны быть определены как экземпляры классов, которые сами по себе определяются достаточно сложно с помощью инструкции class. Функции же просто задаются своей сигнатурой.

В популярных объектно-ориентированных языках, к сожалению, ситуация противоположная: явное состояние почти всегда используется "по умолчанию", а вот функции обычно синтаксически громоздки, если их вообще разрешено определять. В Java и C# например вообще нет синтаксической поддержки функций, а атрибуты объектов по умолчанию stateful, если не объявлены явно как final.


# Унифицированный объектный синтаксис
Синтаксис языка должен помогать, а не мешать программистам в разработке и написании кода и рассуждениях о программе. Важный принцип при разработке синтаксиса языка -- это когда форма отражает содержание, и наоборот. Различия в семантике должны быть заметны как различия в синтаксисе, и наоборот. Например, условный оператор цикла практически всегда записывается примерно так: while условие do тело. Синтаксис записи условия до тела отражает тот семантический факт, что условие будет вычислено и оценено до выполнения цикла.

Должны ли все операции над сущностями языка иметь единый синтаксис? Это не обязательно улучшает читабельность кода; выразительность в таком случае перемещается на второй слой синтаксиса -- например, в наглядные имена объектов и классов, однако и язык делается более многословным. Ещё больше увеличивается многословность кода при параллельном программировании в объектном синтаксисе, потому что унифицированный синтаксис подразумевает явную синхронизацию.