# 1. Наследование
АТД с поддержкой состояний очень полезны при организации программы. Фактически, программа может быть построена в иерархическом стиле -- как АТД, которые зависят от других АТД (идея компонентного программирования). Объектно-ориентированное программирование развивает эту идею на один шаг, основываясь на том, что компоненты часто имеют много общего. Например, возьмем последовательности. Существует множество различных АТД, которые будут "последовательными". Иногда мы хотим, чтобы они вели себя как стеки, иногда -- как очереди, и так далее, с десятками разных возможностей. Но все эти последовательности поддерживают основное, линейно-упорядоченное свойство последовательности. Как мы можем реализовать это всё без дублирования общих частей?

ООП отвечает на этот вопрос введением дополнительной концепции наследования. АТД может быть определён как "наследник" других АТД, т.е. иметь практически такую же функциональность, ну и, возможно, вносить в неё некоторые модификации и расширения. При этом достаточно указать лишь различия между АТД и его родителем.
Такое постепенное/частичное/относительное (относительно родителя) определение АТД называется "класс".

Однако наследование вносит существенное различие между ООП и большинством других видов программирования, где используются состояния. **Наследование -- это техника программирования**. Вычислительная модель, лежащая в основе ООП -- это всё та же stateful-модель. ООП обеспечивает лишь синтаксическую поддержку наследования путем добавления концепции классов в качестве лингвистической абстракции.

На самом деле наследование -- это семантически весьма богатая концепция, которая может быть довольно хитрой, что подробно изучается на втором курсе ООАП. Существует множество способов построения АТД путем модификации других АТД. Основной подход, используемый в ООП -- синтаксический: новый АТД-потомок определяется путем выполнения простых синтаксических манипуляций с существующим АТД. Но так как результирующие изменения в семантике не всегда легко вывести из синтаксиса, то такие манипуляции должны выполняться с большой осторожностью, в идеале, с хорошим контролем со стороны компилятора/тайп-чекера.


Компонентный подход для строительства систем намного проще. Компонент группирует любой набор сущностей, и рассматривает их как единое целое с точки зрения зависимостей между ними. Компонент строится из подкомпонентов с уважением к их спецификациям.

Несмотря на определённые проблемы, наследование обладает большим потенциалом: каждая абстракция может быть реализована всего один раз, причём все реализации независимы -- изменение одной реализации не требует модификации других реализаций.

Более того, различные реализации, как правило, отличаются лишь немного, что делает неочевидными внесение в них изменений, и такое нечёткое "дублирование кода" абстракций является одним из самых больших источников ошибок в компонентной модели. Наследование предлагает исключить такое дублирование.

Однако потенциал, обещаемый наследованием, происходит ценой "распыления" реализации АТД в разных кусках программы. Реализация АТД редко когда собрана в одном месте, разве что в небольших проектах. Как правило, АТД включает в себя через композицию или наследование другие АТД, размещённые неизвестно где. Вдобавок части реализации могут существовать вообще только в виде скомпилированного кода, без доступа к исходникам.

Ранее считалось, что наследование решит проблему повторного использования кода -- упростит создание библиотек, которые можно будет массово передавать третьим лицам для использования в других проектах. На практике это не сработало. Неудача наследования как метода повторного использования очевидна из успеха других техник -- компоненты, фреймворки, шаблоны проектирования. Наследование остается полезным лишь в рамках одной системы или тесно связанного семейства программ, но при этом занимает достойное место рядом с программированием высшего порядка, как один из наиболее важных методов структурирования программы.

# Инкапсулированное состояние и наследование

Классическая область ООП возникла как сочетание инкапсуляции, явного состояния и наследования. В этой области была разработана богатая теория и множество практик на тему "как писать stateful-программы с использованием наследования". Однако со временем возник явный перебор: сильная концепция "всё есть объект" из языка Smalltalk, насильственно привитая языкам мэйнстрима, стала и существенным их ограничением из-за смешения понятий состояния и инкапсуляции. Современные объектно-ориентированные языки чрезмерно игнорируют преимущества, которые можно получить, применяя другие сущности, отличные от объектов, и используя инкапсуляцию без состояния. Далее мы подробно рассмотрим эти моменты.

Засада в том, что большинство объектно-ориентированных языков программирования по умолчанию считают, что АТД должен иметь явное состояние -- даже Smalltalk, не говоря уже о C++ и Java.

Явное состояние -- сложное понятие, и оно не должно быть первым понятием, которому учат программистов с нуля. Существуют более простые приёмы программирования, которые мы рассматривали на предыдущих курсах: например, использование идентификаторов для ссылки на значения, или dataflow-переменные. Все эти более простые способы должны быть изучены прежде, чем совершится переход к работе с явным состоянием.

# Объекты и классы

Объект -- это сущность, которая инкапсулирует состояние таким образом, что доступ к нему за границами объекта может быть получен только контролируемым образом -- с помощью методов, которые представляют собой процедуры, доступные извне, и которые могут внутри объекта непосредственно обращаться к внутреннему состоянию. Единственный способ изменить состояние объекта -- это вызвать соответствующий метод. Это гарантирует, что состояние объекта всегда удовлетворяет некоторому инвариантному свойству.

Класс -- это сущность, которая определяет объект некоторым "постепенным" способом (разными кусочками). Объект в смысле экземпляра класса определяется классами, от которых он наследуется, и тем, чем он отличается от прямых предков. Большинство современных языков поддерживают концепцию классов как лингвистическую абстракцию, чаще всего через простую, но мощную синтаксическую конструкцию class.