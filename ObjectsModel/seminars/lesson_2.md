# 2. Классы как полноценные АТД
Основа концепции объекта -- контролируемый доступ к инкапсулированным данным.

Поведение объекта задается классом. В самом общем случае __класс -- это (частичное) определение АТД в виде модификации других АТД.__

Богатый набор понятий для определения классов классифицируется двумя схемами -- в зависимости от того, позволяется ли классу определять АТД только полностью, или постепенно/частично.

__Полное определение АТД__. Тут, в свою очередь, два подхода.
- Конструирование класса из методов, свойств и атрибутов. Атрибуты могут инициализироваться с привязкой либо к объекту, либо к классу.
- Использование динамической типизации (сообщения первого класса и атрибуты первого класса, см. далее). Становятся доступными мощные формы полиморфизма, которые очень трудно или вообще невозможно реализовать в языках со статической типизацией. Расплатой же за такую свободу становится заметно возрастающая вероятность довольно простых ошибок, связанных с проcтой невнимательностью (в предыдущем подходе такие ошибки ловит компилятор или тайп-чекер).

__Постепенное определение АТД__. Тут -- все концепции, связанные с наследованием (как класс связан с другими классами).

Мы принимаем, что __класс -- это лингвистическая абстракция в языке__, определяемая с помощью ключевого слова (например, class).

Классы в языке считаются __значениями первого класса__ (в идеале), как минимум класс в коде определяется так же легко, как и функция. Класс содержит __атрибуты__ ("внутренние" переменные) и __методы__ для работы с этими атрибутами. C атрибутами можно работать как с обычными переменными -- считывать их значения и менять их значения (концепцию видимости атрибутов и методов пока не затрагиваем). __Работа с атрибутами и методами имеет синтаксис, отличный от работы с обычными переменными и функциями.__
Это -- всё, что минимально необходимо для добавления в язык объектной парадигмы.

Строго говоря, __концепция класса в stateful-модели может быть реализована и без расширения синтаксиса языка программирования.__ В классических императивных языках активно используется концепция модуля, который предоставляет некоторый интерфейс -- набор функций, а эти функции обращаются к "внутренним" переменным в части реализации модуля, обычно не видимым за пределами этого модуля.

Класс -- это структура данных, которая задаёт внутреннее состояние объекта (значения атрибутов), его поведение (методы), наследуемые классы, и несколько дополнительных свойств и операций.

Более универсальное определение такое, что __класс -- это структура данных, которая описывает АТД и предоставляет его полную или частичную реализацию.__

На основе класса может быть создано произвольное количество объектов (экземпляров класса). Обращение к объекту (прежде всего, вызов его метода) называется __отправкой сообщения объекту.__

Обращение к объекту синхронно, как и обращение к функции: оно считается завершенным, только когда соответствующий метод полностью закончит работу.

Класс конструируется из трёх видов частей, которые называются члены (__mermbers__) класса. Различают три вида членов класса:

- __Атрибуты__. Атрибут -- это ячейка, которая содержит "кусочек" состояния экземпляра класса. Атрибут также называют поле класса или переменная класса. Тип атрибута может быть любой допустимый в языке. В классической модели ООП, которая рассматривается на данном курсе, атрибуты доступны исключительно внутри класса (полностью в нём скрыты и недоступны извне), но при этом свободно наследуются классами-потомками.

- __Методы__. Метод -- это вид процедуры, который привязан к контексту конкретного экземпляра класса (вызывается этим экземпляром) и имеет доступ к атрибутам этого объекта (класса). Метод может иметь список параметров, как и обычная функция.

- __Свойства (properties)__. Свойства класса задают либо специфическое поведение объекта (экземпляра класса) во внешнем мире, либо специфическую характеристику самого класса. Например, может задавать блокировку объекта (когда любой его метод может выполнять только один поток, доступ других потоков ко всем его методам блокируется, чтобы не возникало коллизий), или запрет на расширение класса потомками. На практике специальные свойства также допускаются для конкретных методов и атрибутов.


Атрибуты класса дополнительно подразделяются по способу своей инициализации.

1. Атрибут может быть проинициализирован с привязкой к конкретному объекту (для этого в языках программирования обычно применяются префиксы наподобие self или this) -- фактически, в конструкторе, хотя формальное понятие конструктора в классическую модель ООП не входит (оно лишнее, фактически это синтаксический сахар).

2. Атрибут может быть проинициализирован с привязкой к самому классу в целом. Тогда во всех экземплярах этого класса его значение будет одно и то же. Этот подход реализуется в популярных языках через так называемые статические атрибуты класса (или поля класса, а не объекта).

3. Есть ещё одна форма инициализации с привязкой к классу -- так называемый бренд. Бренд -- это набор классов, которые связаны между собой каким-либо образом, но не наследованием (например, дружественные классы в С++). Атрибуту бренда может быть присвоено значение, одинаковое для всех участников бренда путем инициализации одной и той же переменной класса.

__Атрибуты первого класса.__

Имена атрибутов в общем случае могут "вычисляться" во время работы программы. Например, в качестве некоторого аргумента метод получает строку, которая интерпретируется как имя аргумента (для чего требуется, чтобы класс открыл публичный доступ к своим атрибутам). Такая возможность опасна и чревата сложными ошибками, но полезна при отладке.

# Методы и сообщения первого класса ("класса" в смысле "вида" или "порядка")

Принцип прост: сообщения -- это записи, а заголовки методов -- это паттерны, которые выполняют разбор записей. Когда объект получает сообщение (ему некоторым образом передаётся значение в виде записи), автоматически подбирается метод, точно подходящий по своим параметрам для обработки этой записи.

Этот механизм, в частности, реализован в Julia и называется Multiple dispatch. По мнению создателей этого языка, такой подход для мультипарадигмального языка обеспечивает гораздо большую гибкость, нежели классическая схема "присоединения" методов к классам, решая, в частности, проблему сильной связности, возникающей из-за необходимости использовать self/this.

Выбор соответствующего метода ("обработчика" сообщений) может происходить как в момент компиляции в языках со статической типизацией, так и в момент работы программы в языках с динамической типизацией.

Сам метод-обработчик может задаваться как с фиксированным числом параметров, так и с гибким, когда в дополнение к фиксированному списку параметров (или сразу вместо него) добавляется условное "..." -- произвольный список дополнительных параметров, заранее неизвестный. В Python например имеется такая возможность, когда к дополнительным параметрам можно обращаться по их индексам в заголовке, или по именам-ключам в словаре. В общем случае ссылка на заголовок метода со всеми его параметрами может сама по себе быть именованной, когда аргументы "упаковываются" в одну запись.

Параметры могут задаваться со значениями по умолчанию, которые они получают, если явно не заданы в конкретном вызове метода.

Наконец, метод может быть оснащён отдельным свойством (называемым, например, otherwise), которое задаёт, что данный метод будет вызван, если не будет найден (по своему заголовку) никакой другой метод для обработки сообщения. Такой метод не может быть в программе единственным (без других методов). Он имеет один параметр, получая в его качестве любое необработанное сообщение. Данный механизм реализует концепцию делегатов, как альтернативу наследованию и интерфейсам.


Вышеописанная концепция класса с атрибутами, методами/сообщениями и свойствами предлагает __удобный синтаксис для определения АТД с инкапсулированным состоянием и множеством операций.__

В дополнение к такому синтаксису, в общем случае желательна поддержка "классов как значений", которые сохраняют все преимущества процедурных значений. Классы композиционны и могут быть вложены в классы. Они совместимы с процедурными значениями: классы могут быть вложены в процедуры, и наоборот. Но в популярных языках программирования такие гибкие возможности обычно отсутствуют.

