# 4. Программирование с использованием наследования

### Корректное использование наследования
#### Понимание наследования через типы.
В данном случае мы считаем, что классы -- это типы, а классы-потомки -- это подтипы. Представление классов как типов соответствует принципу, что классы должны моделировать сущности реального мира, или некоторые абстрактные версии этих сущностей. Тогда классы должны удовлетворять свойству подстановки (LSP): каждая операция, которая работает для объекта класса C, также работает аналогичным образом для объектов подкласса С (классы-наследники не должны ломать "интерфейсы" родительских классов). Большинство объектно-ориентированных языков (Java, C++, C#...) разработаны именно под данный случай, но в них через свободное переопределение методов можно довольно легко нарушить этот принцип.

#### Понимание наследования через структуру.
С этой точки зрения, наследование -- это просто ещё один инструмент программирования, который используется для структурирования программы. Эта точка зрения категорически не рекомендуется, поскольку такая работа с классами вообще не учитывает свойство подстановки. Структурный подход -- это бесконечный источник ошибок и плохих проектов.

С точки зрения типов, каждый класс стоит на своих собственных ногах, так сказать -- как полноценный АТД. Это справедливо даже для классов, имеющих подклассы; с точки зрения класса-наследника, родительский класс -- это АТД с единственным доступом к нему через методы (атрибуты родителя скрыты от прямого доступа). А с точки зрения структуры классы становятся просто строительными лесами, которые используются только для структурирования программы.

В подавляющем большинстве случаев наследование должно полноценно поддерживать вариант "классы как типы"; иная схема приводит к тонким и губительным ошибкам. Пожалуй, единственный случай, когда допускается структурный подход -- если требуется менять поведение самой объектной системы как таковой. Но всё равно этим должны пользоваться только опытные программисты, и только если не сработали другие подходы (например, мета-объектные протоколы).

# Конструирование иерархии через следование типу

На курсе по декларативной парадигме отмечалось, что когда мы пишем рекурсивную программу, полезно сперва определить тип обрабатываемой структуры данных, и затем конструировать программу через следование этому типу. Аналогичный принцип хорошо подходит и при конструировании иерархий наследования.

Возьмём, для примера, список List<T>, который, напомню, рекурсивно определён как либо nil (отсутствие значения), либо элемент-голова типа T, сцепляемый с оставшимся списком List<T>. В парадигме ООП определяем абстрактный родительский класс ListClass (например, с методами isNil и append), у которого будут два наследника: NilClass и ConsClass. Экземпляром класса NilClass будет пустой список (что сохраняет принцип подстановки), и тогда ConsClass естественно выражается через NilClass и ConsClass.

# Общие/обобщённые классы (классы-генерики)
Peter Van Roy под "generic class" понимает не программистские генерики, когда класс параметризуется другим типом/классом (например, List<T>), а класс, который определяет часть функциональности АТД. Сам по себе он должен быть полностью реализован, прежде чем его можно будет использовать для создания объектов.

Предлагаются два способа определения общих классов: через наследование ООП, и через программирование высшего порядка, и на самом деле первый способ -- лишь синтаксический вариант второго. Другими словами, наследование -- это стиль программирования, базирующийся на программировании высшего порядка.

Универсальный способ делать классы "более общими" в ООП -- это использовать абстрактные классы. Например, имеется абстрактный класс GenericSort, который реализует алгоритм сортировки списка, по определению подразумевающий сравнение сортируемых элементов. Однако такое сравнение зависит от типов этих элементов, поэтому от GenericSort наследуются классы (например, IntegerSort, StringSort), которые реализуют такое сравнение уникальным для соответствующего типа образом.

Второй путь создавать классы-генерики сам по себе более общий, но во многих массовых языках поддержка такого способа отсутствует. Так как сами классы в идеале -- значения первого класса, __мы__ создаём функцию, которая получает подходящую функцию сравнения (например, функцию сравнения целых или строк) и возвращает класс, "настроенный" на это сравнение. Но такое динамическое создание классов, как говорилось, возможно далеко не везде.

Поэтому, по сути, мы используем наследование, чтобы "подключить" одну операцию к другой. Наследование -- это просто форма программирования высшего порядка, когда первая операция передаётся второй. В чём разница между этими двумя техниками? В большинстве языков программирования иерархия наследования должна быть явно определена на этапе компиляции. Это даёт определённые преимущества: компилятор может генерировать лучший код, а тайп-чекер сможет делать больше проверок на ошибки. Программирование высшего порядка позволяет определять новые классы непосредственно во время выполнения программы. Это дает большую гибкость, а традиционная расплата -- усложнение отладки.

# Множественное наследование
Множественное наследование во многих популярных языках не поддерживается, а там, где поддерживается, пользуются им очень ограниченно. Множественное наследование позволяет потенциально представлять сложные вещи довольно удобными конструкциями. Например, Бертран Мейер приводит пример, когда имеется класс "геометрическая фигура", от которого наследуются обычные фигуры. Однако фигура может также составляться из нескольких фигур, и тогда соответствующий класс "составная фигура" может наследоваться как от "геометрической фигуры", так и от контейнера -- например, от списка.

В реальных проектах подобная поддержка множественного наследования бывает важна -- когда требуется в дополнение к некоторому "основному" наследованию добавить совершенно иные характеристики (например, свойство упорядоченности, сортируемости, "рисуемости", композиционности...). __По этой причине в языках C# и Java например вместо множественного наследования классов поддерживается множественное наследование интерфейсов.__ _(прим. Как будто это в целом более безопасная практика, нежели множественное наследование классов)._

# Диаграммы классов
В 1990-е и начало 2000-х получила большую популярность концепция визуального моделирования -- представление иерархий классов в виде диаграмм. Был, в частности, разработан так называемый универсальный язык моделирования UML, реализовывалось множество попыток создания визуальной модели предметной области на UML, и затем её отображение в программный код, однако ни одна из них так и не завоевала даже небольшой популярности. Причин этому три:

- UML не определяет функциональность класса. Например, если методы поддерживают некоторый инвариант, то этот инвариант не отображается на диаграммах;

- UML не умеет моделировать (или делает это очень слабо) динамическое поведение, эволюцию программы во времени. Для разных фаз работы программы обычно требуются разные диаграммы. Приложения часто работают параллельно, независимыми частями, которые взаимодействуют некоторыми согласованными способами, которые нужно тоже наглядно представлять;

- UML моделирует только один уровень в иерархии компонентов системы.

Подход UML частично признаёт эти ограничения и предоставляет инструменты, которые как-то облегчают их: например, есть диаграммы взаимодействия для динамического поведения и диаграммы пакетов для иерархии. Но на практике в итоге процесс моделирования оказывается весьма сложным, подразумевается довольно высокий порог входа, а итоговый выигрыш слабо понятен.

# Паттерны проектирования
При разработке программных систем часто приходится сталкиваться с одними и теми же проблемами снова и снова. Причина этого, скорее всего, в том, что люди, обучающиеся схожими способами, делают схожие ошибки. Подход, основанный на паттернах проектирования, явно это декларирует и предлагает "шаблонные" решения.

Паттерн проектирования -- это инженерная техника, которая решает одну из общих типовых проблем. Данный цикл курсов "как понять в программировании всё" в некотором смысле полон таких паттернов проектирования, только они формировались в основном научным подходом, а не обобщением типовых ошибок проектирования. Например, в декларативном программировании это правило "конструировать программу, следуя типу (рекурсивной структуре данных)", а при создании защищённых АТД использовался паттерн "обертывание функциональности в безопасный слой", который применим к любому АТД.

Впервые паттерны проектирования были популяризированы в известной книге "Design Patterns: Elements of Reusable Object-Oriented Software" ("Приемы объектно-ориентированного проектирования. Паттерны проектирования") от Банды четырёх (Гамма, Хелм, Джонсон, Влиссидес), в которой предлагается каталог паттернов проектирования в ООП и объясняется, как их использовать. В каталоге приводятся паттерны, основанные на наследовании.# 

Давайте рассмотрим типичный паттерн проектирования с точки зрения программиста, который думает в терминах моделей вычислений.

Классический паттерн Компоновщик (Composite) предназначен для формирования иерархии объектов. Пусть имеется некоторая иерархия объектов, которые могут быть вложены друг в друга: например, графическая фигура, которая может представлять собой либо конкретную фигуру, либо контейнер графических фигур. В теме множественного наследования предлагался вариант, когда графическая фигура наследуется одновременно от абстрактной фигуры и от списка. Паттерн Компоновщик предлагает более абстрактный подход: иерархия строится из компонентов, поддерживающих интерфейс Компоновщика (операции add и remove и некоторая универсальная execute), которые в свою очередь могут быть либо конкретным объектом, либо контейнером, содержащим дочерние компоненты с этим же интерфейсом. Внутренняя реализация Компоновщика может использовать произвольные подходящие структуры данных.

Потребность в паттернах наподобие Компоновщика возникает прежде всего потому, что в популярных языках отсутствует возможность использования классов как значений, иначе, получив на вход класс, функция компоновки могла бы вернуть новый класс, расширенный указанным интерфейсом. Но и тут есть ограничения, так как даже в случае поддержки классов как значений функция компоновки должна вернуть суперкласс (класс-родитель) для заданного класса, а на практике реализации такого программирования высшего порядка позволяют создавать лишь класс-потомок (так как новый класс-родитель должен аккуратно вписаться в вышестоящую иерархию, которая в общем случае неизвестна).

Подобную двойственность в отношении паттернов проектирования как, по большому счёту, вынужденных приляпок из-за фундаментальных ограничений конкретного языка программирования, предлагается решать так: рассматриваем эти паттерны в первую очередь как способ инженерного мышления; совершенно не обязательно, чтобы они нативно поддерживались в языке программирования. Конструкции паттернов легко реализуются во всех популярных языках (Java, C#, Python, C++, PHP, JavaScript...), и хотя они не поддерживаются в них как полноценные встроенные абстракции, их несложно внедрить, например, с помощью препроцессора или системы макросов.

