# 38. Базовый принцип проектирования иерархий классов

"Естественный", наивный способ проектирования наследования, характерный и для программистов, и для людей, не знакомых ни с программированием, ни с проектированием -- это подход "сверху вниз" (от общего к частному), когда сперва определяется родительский класс, и затем постепенно к нему добавляются более специфичные потомки.

Естественность действительно часто хороша для описания иерархии, однако она совсем не лучший способ в процессе её создания. Когда мы смотрим на готовую иерархию, она нам часто кажется очевидной, однако при попытке создать что-то подобное на практике начинаются сложности. Дело в том, что людям гораздо привычнее выявлять, обнаруживать сначала частные случаи, и только потом их обобщать. В жизни мы встречаемся исключительно с реальными частностями, а любые их обобщения потом додумываем в голове.

Поэтому, главное правило -- **не спешить с родительскими абстракциями**. Постепенно накапливайте список различных сущностей, которые явно подразумеваются в проекте, а формирование их предков, добавление нового уровня абстракции, откладывайте. Довольно часто выбрать одну форму обобщения сразу не удаётся, абстракций обычно допускается несколько, и какой вариант, какую категорию наследования взять, зависит от проектных требований, от нужд заказчиков, от потребностей других разработчиков.

Например, односвязный список можно обобщить до
-- универсального списка с курсором (как мы делали на первом курсе);
-- графа -- структуры, где допускается множество связей между узлами;
-- очереди;
-- перечислимой, последовательной структуры данных.

Иногда конечно удаётся двигаться и сверху вниз, от быстро находимой абстракции к частному, но такой подход подразумевает большой опыт проектирования, поэтому лучше всегда начинать с конкретных классов.

**Наследование -- это создание новой реализации на основе старой**. Аналогично, вы расширяете интерфейс, просто добавляя еще пару методов. Никакого наследования.

Если вы планируете просто добавить новые функции в класс (надеюсь, не забыв про SRP), то вы можете использовать композицию или наследование, код получится почти одинаковым, тривиально преобразуемым в оба варианта, без разницы.

Этот подход фактически присутствует и во многих функциональных языках в виде тайп-классов.

Дело в том, что вы не можете использовать "родительский класс" (пусть и абстрактный) как "интерфейс" хотя бы потому, что не будет нормально работать тайп-чекинг. Классы это реализации интерфейсов, их некорректно смешивать, согласно теории типов.

Вообще, наследование это труднейшая часть теории объектов. Обвинять кого-то, что он "не понимает наследование" всё равно, что обвинять его, что он "не понимает алгебру/пространство Chu применительно к квантовой физике".
