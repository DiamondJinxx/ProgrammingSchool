# 40. Небольшое заключение про тренды развития ООП

В целом сегодня парадигма ООАП остаётся самой массовой практикой проектирования, однако её популярность заметно снижается, так как даже в небольших проектах построение иерархии наследования может вызывать заметные сложности, о которых на курсе неоднократно рассказывалось. В целом, практика использования наследования сокращается весьма быстро, даже в довольно крупных проектах иерархии насчитывают буквально 1-2 очевидных уровня, в основном классы применяются больше для удобства, для инкапсуляции данных и кода.

Основным механизмом организации отношения между классами сегодня стала композиция. Активное применение отношения "содержит" сформировалось даже в отдельную механику проектирования, распространённую модель Dependency Injection (внедрение внутренней зависимости от другого класса).

Однако такая чрезмерная популярность has-a привела к распространению классической проблемы: как понизить сцепление (coupling), когда из-за чрезмерно активного применения композиции излишне увеличивается взаимосвязь между модулями, и как усилить связность (cohesion) -- внутреннюю связанность элементов внутри модуля.

Coupling/cohesion очень хорошо решается с помощью АТД. Каждый абстрактный тип задаёт собственный, автономный, семантически тесно связанный набор операций над конкретной структурой данных (сильная связность), а все отношения "содержит" полностью инкапсулируются, скрываются внутри реализации и на уровне публичного интерфейса АТД не видны (практически отсутствует сцепление между модулями). В результате абстракции не зависят ни от деталей реализации, ни от других модулей, в том числе и нижестоящих, что гарантируется схемой наследования пред- и постусловий. Эта концепция в частности вошла в SOLID как пятый принцип инверсии зависимостей Dependency inversion principle (DIP).

Возможно, в частности и по этой причине, концепция АТД сегодня превращается в мэйнстрим. Например, она хорошо реализована в Rust -- языке, который сегодня всерьёз конкурирует с С++ и активно применяется в системной разработке (например, на Rust частично переписывается Windows), поддерживается в языках Go, Swift и др.

[Хорошая статья по SOLID (2020-й год, перевод) от Дядюшки Боба](https://habr.com/ru/post/561216/), где он объясняет, относительны ли эти принципы, или вечны.
[И её версия 2021-го года, с забавными обсуждениями :)](https://habr.com/ru/post/581912/)

Обязательно изучите из СильныхИдей

- материал "Когда наследование лучше композиции",
- пять материалов по продвинутому пониманию SOLID,
  (каждый из принципов с точки зрения функционального программирования),
- пять материалов по хейту SOLID,
- пять материалов по Anti-SOLID (что приходит SOLID на смену),
- 94-й "Дополнение к курсу ООАП-2",
- 96-й "Выявляем хорошие абстракции для интерфейсов".

И также полезно будет познакомиться с [принципами GRASP](https://bool.dev/blog/detail/grasp-printsipy) по назначению ответственностей классам.

Напишите, что полезного в прикладном плане вы вынесли для себя из этой теории, и как это полезное будете применять на практике, прежде всего в свой работе.
Или же, что вы особо ничего не поняли и не вынесли для себя ничего полезного :)
