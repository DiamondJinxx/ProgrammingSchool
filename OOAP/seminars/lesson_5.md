# Конструкторы

Важный момент, что в программе всегда должен создаваться **согласованный объект**, как ранее говорилось. Для этого подчас имеет смысл запретить прямое создание объектов через вызов конструктора, так как в некоторых языках допускаются неявные конструкторы по умолчанию, которые потенциально могут привести к появлению несогласованных объектов. В классических паттернах проектирования предлагаются паттерны Фабрика и Фабричный метод, которые можно использовать для наглядного производства согласованных объектов в разных форматах.

Главная идея, **что объекты в программе должны создаваться всегда в согласованном формате и только по явному безопасному запросу, вызовом особой функции класса, которая новые объекты создаёт.**

В простых случаях можно ограничиваться указанием постусловия для конструктора:

```csharp
abstract class Stack<T>

// конструктор
    public Stack<T> Stack(); // постусловие: создан новый пустой стек

// постусловие: в стек добавлено новое значение
    public void push(T value); 

// предусловие: стек не пустой; 
// постусловие: из стека удалён верхний элемент
    public T pop(); 

// предусловие: стек не пустой
    public T peek(); 

    public int size();

// постусловие: из стека удалятся все значения
    public void clear();
```
Обратите внимание на синтаксис записи конструктора. Конструктор -- это функция (запрос), которая создаёт новый объект, поэтому в спецификации АТД правильно указывать тип возвращаемого им значения.

_Интересный момент, что в математическом смысле вполне можно считать, что все возможные объекты уже были некогда созданы изначально, и подобная функция создания нового объекта на самом деле просто возвращает уже существующий объект, находя его по заданным характеристикам._

# Результаты работы команд и функций

Функция возвращает только то значение, которое напрямую от неё требуется по спецификации. Команды вообще никакого значения не возвращают. Как в таких случаях узнать, как они отработали? Вдруг возникли ошибки, или, например, результат работы команды подразумевает достаточно сложный эффект, как получить детальную информацию?

Правильный ОО-подход подразумевает не усложнение формата результата, в который пакуется много информации (и само вычисленное значение, и код ошибки, и статусы...), и не передачу значений через модификацию своих аргументов, **а явное выполнение дополнительных запросов, которые вернут нужный результат и конкретный статус.**

Например:

```
make_command( ... );
status = get_make_status();
```

Функция get_make_status() всегда будет возвращать статус последней выполненной команды make_command(). Внутри класса этот статус сохраняется в одном из скрытых атрибутов. Но спецификация АТД, конечно, определяет и команду make_command(), и функцию get_make_status(), чётко регламентируя их работу и взаимосвязь, но никак не задавая их реализацию, и даже не давая на это никаких намёков. Это одно из полезных следствий разделения абстрактного и прикладного побочных эффектов, о которых говорилось выше.

# Ошибки и исключительные ситуации

Насколько корректно в коде использовать инструкции контроля за исключительными ситуациями? В целом предлагаемый стиль ООП контринтуитивно подразумевает избегание такого контроля в коде.

Но что делать, если функция потенциально может отработать ошибочно? Например, если функция ввода целого числа с клавиатуры получает некорректное значение, и завершается ошибкой, то что она должна возвращать? Надо ли например в таком случае формировать внутри неё исключение?

**С помощью команд и запросов мы определяем абстрактную вычислительную модель работы с состоянием объекта (машину состояний).** При таком подходе функция, которая может возвращать как основное значение, так и некоторый признак ошибки (плохой способ реализации такого подхода -- возвращать null как признак, что что-то пошло не так), переделывается в команду. Её результат и статус (отработано нормально или возникла такая-то ошибка) выдаются двумя разными запросами. Такая схема часто реализуется, когда надо организовать взаимодействие с внешним миром (ввести значение с клавиатуры, из файла или базы, получить по сети и т. д.), которому возможные ошибки присущи по определению.

_Здесь возможна рекурсивная проблема: если запрашивается результат для функции, которая ещё не срабатывала, то что запрос должен возвращать? Если он возвращает некоторое значение по умолчанию, а программист забыл проверить статус функции (в данном случае статус вернётся ошибочный: функция ещё не вызывалась), то это значение по умолчанию продолжит использоваться далее как верное. Вот в таких вторичных ситуациях вполне возможно генерировать исключение изнутри запроса результата, если сам результат пока не определён (что определяется внутри этого запроса вызовом запроса статуса)._

На практике далеко не во всех случаях удаётся проконтролировать работу методов через последующие запросы статуса их выполнения. Вполне вероятны ситуации, когда какие-то внешние сбои (на уровне операционной системы или аппаратной части) приведут к достаточно глобальным искажениям, для реагирования на которые простого контроля за статусом последнего метода недостаточно. Возможно, и какие-то программистские ошибки в коде могут теоретически приводить к достаточно серьёзным последствиям, которые потенциально допускать нельзя. Наконец, и сам разработчик при реализации сложной логики может заранее добавлять обработчики исключений.

Рекомендация в целом такая, что с **явной обработкой исключений в коде спешить не надо.** Лучше использовать по максимуму возможности стандартных библиотек, где нередко присутствуют "страховочные" версии различных типовых функций. Например, функция преобразования строки в число может завершаться исключением, если строка в неправильном формате, однако страховочная версия такой функции возникновения ошибки не допустит, и предложит расширенную диагностику своей работы, включая коды возможных ошибок.
Но если такой возможности нету, а ситуация явно подозрительная, тогда надо добавлять обработчики исключительных ситуаций.

# Команды и запросы

Теперь в свете принципа команд и запросов пересмотрим остальные имеющиеся у нас методы стека (в дополнение к конструктору).

push() -- это явная команда. Она не возвращает никакое значение, и модифицирует стек в соответствии с постусловием.

А вот в случае с pop() сразу выявляется конфликт. Этот метод с одной стороны, функция/запрос, которая возвращает верхний элемент, а с другой стороны, она одновременно меняет состояние стека, удаляя из него этот элемент (то есть должна быть оформлена как команда). И так как у нас уже есть запрос peek(), возвращающий верхний элемент стека, но не меняющий его, метод pop() надо представить в виде команды, которая просто удаляет верхний элемент, если стек не пуст.

Поэтому правильное определение метода pop() будет таким:


```csharp
// предусловие: стек не пустой; 
// постусловие: из стека удалён верхний элемент
public void pop(); 
```
Метод size() -- это запрос, чистая функция, не влияющая на состояние стека, а метод clear() -- это команда, которая работает на всём множестве допустимых значений (то есть не требует предусловия).

Остались два метода (команда pop() и запрос peek()), которые требуют предусловий, то есть в некоторых ситуациях (когда стек пуст) их работа пока не определена. Генерация исключения и возвращение кода ошибки, как объяснялось выше, плохие способы реализации специфики методов.
Правильно -- сделать отдельные запросы, которые будут возвращать статус выполнения этих команд. Сами статусы лучше оформить в виде констант в классе.


```csharp
public const int POP_NIL = 0; // push() ещё не вызывалась
public const int POP_OK = 1; // последняя pop() отработала нормально
public const int POP_ERR = 2; // стек пуст

public const int PEEK_NIL = 0; // push() ещё не вызывалась
public const int PEEK_OK = 1; // последняя peek() вернула корректное значение 
public const int PEEK_ERR = 2; // стек пуст

public int get_pop_status(); // возвращает значение POP_*
public int get_peek_status(); // возвращает значение PEEK_*
```
Дополнительные статусы *_NIL -- в данном случае пример, что в целом всегда желательна более точная диагностика ошибок. Например, стеки часто реализуются аппаратно (это позволяет достичь очень высокой скорости работы кода; в частности, поэтом мы изучали реализацию очереди на двух стеках), и возможны ситуации, когда аппаратный стек находится в неопределённом состоянии, пока в него что-то не втолкнулось в первый раз.

Тогда некоторую корректную последовательность работы со стеком целых чисел можно записать так:


```csharp
stack1 = new Stask<int>()
stack1.push( 1 )

// ...

x = stack1.peek()
if stack1.get_peek_status() == Stack.PEEK_OK   
   // обрабатываем x

stack1.pop()
y = stack1.peek()
if stack1.get_peek_status() == Stack.PEEK_OK and
   stack1.get_pop_status() == Stack.POP_OK
   // обрабатываем y
```

Вместо запроса статуса конечно можно использовать size() с явной проверкой количества элементов в стеке. Но в общем случае более правильным подходом будет обращение к запросам статуса состояния. Кроме того, может показаться, что программа загромождается дополнительными проверками, но и в случае генерации исключений или возвращения значения null для пустого стека такие же проверки всё равно потребуются, причём они будут гораздо менее наглядными.


# Финальная версия АТД Stack
Итак, финальная версия АТД Stack запишется так:

```csharp
abstract class Stack<T>

    public const int POP_NIL = 0; // push() ещё не вызывалась
    public const int POP_OK = 1; // последняя pop() отработала нормально
    public const int POP_ERR = 2; // стек пуст

    public const int PEEK_NIL = 0; // push() ещё не вызывалась
    public const int PEEK_OK = 1; // последняя peek() вернула корректное значение 
    public const int PEEK_ERR = 2; // стек пуст

    // конструктор
    public Stack<T> Stack(); // постусловие: создан новый пустой стек


    // команды:
// постусловие: в стек добавлено новое значение
    public void push(T value); 

// предусловие: стек не пустой; 
// постусловие: из стека удалён верхний элемент
    public void pop(); 

// постусловие: из стека удалятся все значения
    public void clear();


    // запросы:
// предусловие: стек не пустой
    public T peek(); 

    public int size();


    // дополнительные запросы:
    public int get_pop_status(); // возвращает значение POP_*
    public int get_peek_status(); // возвращает значение PEEK_*
```
Для команды push() статусы, в принципе, не нужны, так как она всегда отрабатывает корректно. Но для полноты можно добавить статусы PUSH_OK и PUSH_NIL, если push() выполняется в самый первый раз.


## Полнота спецификации АТД
_Теоретическое необязательное отступление._

Можно ли как-то убедиться, что созданная спецификация АТД полностью описывает все свойства определяемых ей объектов? АТД мы основываем, как договорились, на некотором условно уже готовом техническом задании, или наборе требований. Если оно неформально, то, понятно, никаких критериев полноты АТД тут не существует. Но если оно формально, тогда возникает вопрос полноты применительно к самому этому документу.

В идеале можно построить математическую теорию для разрабатываемой системы, которая будет формально определять допустимое множество правильных выражений -- комбинаций вызовов функций АТД с корректными аргументами с применением аксиом. При этом различают правильно построенные выражения и корректные выражения. Первые -- это те, которые компилируются, но в процессе работы могут вызывать ошибки времени выполнения из-за недопустимых операций. Корректные выражения работают всегда корректно, без ошибок времени выполнения (хотя, возможно, и выдают не тот результат, которого от них ожидает разработчик и спецификация).

На практике ограничиваются прагматичным понятием достаточной полноты АТД, подразумевающей достаточно сильные аксиомы. Они позволяют в частности выполнять вывод типа результата для функций АТД и гарантируют, что мы получим хотя бы один результат для каждой из них. Другими словами, всё, что определено нашей спецификацией АТД, обеспечивает корректное вычисление результата для всех функций, и поиск дополнительных характеристик АТД можно прекратить. Однако теоретически не исключено, что аксиомы могут приводить к выводу нескольких значений выражения, поэтому второе свойство достаточной полноты -- это непротиворечивость. Она гарантирует, что для каждого выражения будет выведено не более одного значения.

Проблема, что в общем случае доказать достаточную полноту, и даже непротиворечивость, невозможно -- эта задача алгоритмически неразрешима за конечное время. Однако для конкретной спецификации АТД это доказать, как правило, возможно.