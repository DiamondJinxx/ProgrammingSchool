2.2. Операция tail не должна быть сводима к другим операциям, потому что правильная реализация связанного списка подразумевает хранение как условного внутреннего элемента head_pointer (указатель на голову списка), так и условного элемента tail_pointer (указатель на хвост списка). В противном случае операция tail, выраженная через head, right и is_tail, потребовала бы O(N) ресурсов.

Это пример того, что при проектировании АТД надо обязательно учитывать и эффективность его реализации!

2.3. Операция поиска всех узлов с заданным значением больше не нужна, потому что вместо неё введена логика последовательного перемещения курсора к следующему искомому элементу с нужным значением.

2.1. АТД LinkedList

```csharp
abstract class LinkedList<T>

  // конструктор
// постусловие: создан новый пустой список
  public LinkedList<T> LinkedList();

  // команды
// предусловие: список не пуст; 
// постусловие: курсор установлен на первый узел в списке
  public void head(); 

// предусловие: список не пуст; 
// постусловие: курсор установлен на последний узел в списке
  public void tail(); 

// предусловие: правее курсора есть элемент; 
// постусловие: курсор сдвинут на один узел вправо
  public void right(); 

// предусловие: список не пуст; 
// постусловие: следом за текущим узлом добавлен 
// новый узел с заданным значением
  public void put_right(T value); 

// предусловие: список не пуст; 
// постусловие: перед текущим узлом добавлен 
// новый узел с заданным значением
  public void put_left(T value); 

 // предусловие: список не пуст; 
// постусловие: текущий узел удалён, 
// курсор смещён к правому соседу, если он есть, 
// в противном случае курсор смещён к левому соседу,
// если он есть
  public void remove();

// постусловие: список очищен от всех элементов
  public void clear(); 

// постусловие: новый узел добавлен в хвост списка
  public void add_tail(T value); 

// постусловие: в списке удалены все узлы с заданным значением
  public void remove_all(T value);

// предусловие: список не пуст;
// постусловие: значение текущего узла заменено на новое
  public void replace(T value); 

// постусловие: курсор установлен на следующий узел 
// с искомым значением, если такой узел найден
  public void find(T value); 

  // запросы
  public T get(); // предусловие: список не пуст
  public bool is_head();
  public bool is_tail();
  public bool is_value();
  public int size();

  // запросы статусов (возможные значения статусов)
  public int get_head_status(); // успешно; список пуст
  public int get_tail_status(); // успешно; список пуст
  public int get_right_status(); // успешно; правее нету элемента
  public int get_put_right_status(); // успешно; список пуст
  public int get_put_left_status(); // успешно; список пуст
  public int get_remove_status(); // успешно; список пуст
  public int get_replace_status(); // успешно; список пуст
  public int get_find_status(); // следующий найден; 
                       // следующий не найден; список пуст
  public int get_get_status(); // успешно; список пуст
```

# Двунаправленный связный список
Следующий тип для рассмотрения -- это двунаправленный связный список. Данный случай будет очень наглядным, он отлично продемонстрирует типичные проблемы проектирования классов, которые не решить "естественным" путём с позиций здравого смысла, или как минимум, без подходящих специфических механизмов самого языка программирования, на которые, однако, полагаться ещё хуже. Ведь мы ориентируемся на минималистичные описания АТД и соответствующие достаточно минималистичные реализации, и какие-то нестандартные технические возможности уже выходят за рамки вычислительной модели ООП, существенно ослабляя проектный потенциал.


## АТД TwoWayList
На первый взгляд, достаточно в АТД LinkedList добавить всего одну новую операцию left (сдвинуть курсор на один узел влево), и мы получим готовый АТД TwoWayList (двунаправленный список). И это действительно так. Но, как уже говорилось, при проектировании очень важно делать акцент на возможности повторного использования всех компонентов, и в частности, на оформление логически связанных классов в автономное и самостоятельное подобие стандартных библиотек. Поэтому в данном случае напрашивается TwoWayList оформить, например, как наследника класса LinkedList, так как у них явно очень много общего. Проектирование с использованием технологий наследования будет рассмотрено на отдельном курсе, но даже в данном совсем простом примере мы сразу сталкиваемся с принципиальными проблемами.

1) Можно попробовать представить TwoWayList как наследника LinkedList, и вроде бы в TwoWayList достаточно будет добавить всего один новый метод left(). Однако при этом потребуется переопределить и большинство методов родительского класса LinkedList, так как их логика уже принципиально отличается от логики работы однонаправленного списка (надо корректировать связи между узлами уже в две стороны). В результате мы не выигрываем, а наоборот проигрываем, только усложняя систему классов. И вдобавок, при любом изменении логики работы со списками придётся вносить почти идентичные правки в несколько классов.

2) Другой вариант -- создать абстрактный родительский класс с общими методами, которые переопределять в классах-наследниках. Однако предыдущая проблема остаётся -- многие родительские методы придётся определять с нуля в каждом классе, причём по своей логике они будут сильно похожи друг на друга, или даже идентичны. А это верный признак плохого проектирования.

3) Можно также наоборот унаследоватьуже сам класс LinkedList от класса TwoWayList, который становится родительским: тогда мы сохраняем всю родительскую логику, поддерживающую перемещение по списку вправо, и всё, что по сути остаётся сделать в LinkedList -- это "всего лишь" скрыть родительский метод left(). Ничего страшного, что методы содержат код работы с двунаправленными связями, для пользователя это незаметно. Ради проектной простоты этой небольшой дополнительной нагрузкой, как правило, почти всегда можно пожертвовать.

И тут возникает другая проблема: популярные языки программирования такую возможность скрытия родительских методов не допускают, и этому есть принципиальная причина. Дело в том, что нередко возникает соблазн совершенно непродуманно применять наследование, примерно как в наших попытках наследовать друг от друга классы, не особо для этого предназначенные. Например, ради какой-то отдельной функциональности можно попробовать унаследовать класс Автомобиль от класса Двигатель -- тут путаются два классических вида отношений "является" и "содержит", не говоря уже о том, что у автомобиля например может быть два двигателя.


## Спасение в частично реализованных классах
И вот теперь, выяснив потенциальные подводные камни каждого из вариантов, мы приходим к достаточно неплохому и теперь уже напрашивающемуся решению: реализовать родительский класс, например, ParentList -- как частично реализованный двунаправленный список без метода left(). В таком случае LinkedList просто будет его прямым наследником, вообще никак родительскую функциональность не расширяющим. И TwoWayList также унаследует все возможности ParentList, а его непосредственная реализация будет представлять всего лишь один новый метод left() (и, вероятно, вспомогательный метод запроса статуса его работы). Это уже упоминавшийся сильный подход частично реализованных классов (хотя в данном случае родительский класс реализован полностью).

Пример с классами LinkedList и TwoWayList -- хорошая иллюстрация потенциальной проектной сложности даже в системе из 2-3 классов, а если их насчитываются сотни или тысячи? Поэтому так важно на всех этапах проектирования, включая проектирование самих классов, тщательно продумывать все нюансы на уровне АТД -- понимая и учитывая, что с большой вероятностью в будущем многое всё равно придётся дорабатывать.

```csharp
abstract class DynArray<T>

  // конструктор
// постусловие: создан пустой массив
  public DynArray<T> DynArray();

  // команды
// предусловие: i лежит в допустимых границах массива; 
// постусловие: значение элемента i изменено на value
  public void put(i, T value);

// предусловие: i лежит в допустимых границах массива; 
// постусловие: перед элементом i добавлен 
// новый элемент с значением value; 
  public void put_left(i, T value);

// предусловие: i лежит в допустимых границах массива; 
// постусловие: после элемента i добавлен 
// новый элемент с значением value;
  public void put_right(i, T value);

// предусловие: нет; 
// постусловие: в хвост массива добавлен 
// новый элемент
  public void append(T value); 

// предусловие: i лежит в допустимых границах массива; 
// постусловие: элемент i удалён из массива;
  public void remove(int i); 

  // запросы 
// предусловие: i лежит в допустимых границах массива;
  public T get(int i); // значение i-го элемента 
  public int size(); // текущий размер массива 

  // запросы статусов (возможные значения статусов)
  public int get_put_status(); // успешно; индекс за пределами массива
  public int get_put_left_status(); // успешно; индекс за пределами массива
  public int get_put_right_status(); // успешно; индекс за пределами массива
  public int get_remove_status(); // успешно; индекс за пределами массива
  public int get_get_status(); // успешно; индекс за пределами массива
  ```