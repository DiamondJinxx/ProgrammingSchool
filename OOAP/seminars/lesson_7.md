# Единая нотация.
# Название класса и аргументы методов

## Единая нотация
При работе с объектами, при вызове их методов мы всегда используем единую нотацию.

Каждая операция подразумевает свой вызов относительно её родительского объекта, который всегда существует в контексте этой операции (метода).

Этот родительский объект, текущий экземпляр для каждой операции в момент её выполнения -- всегда единственный (в языках программирования он обычно обозначается this или self).

Фактически вся объектно-ориентированная нотация определяется совсем небольшим набором из четырёх операций. Самая основная -- это вызов метода объекта:

x.f(a) 
         
где x -- конкретный объект, f() -- метод этого объекта, а -- аргумент этого метода (список аргументов).

Оставшиеся три операции хорошо известны из императивного программирования: это присваивание, выбор по условию и цикл (с поддержкой команд прерываний цикла). И возможны дополнительные инструкции, связанные с отладкой и тестированием (например, assert и log).

Что касается оператора return, то наилучший способ его использовать -- это указывать return в каждом методе ровно один раз, причём самой последней командой.


## Название класса
Название класса напрямую отражает его смысл. Говорить, что класс делает то-то -- явная ошибка. Класс ничего не делает, он группирует в одно целое набор операций над некоторой структурой данных, над объектами одного типа.

Название класса -- это английское существительное, именующее конкретную абстракцию данных (например, BankCard, Stack, Singleton).

В ряде случаев название может быть прилагательным, заканчивающимся на -able, которое характеризует некое общее свойство, например, отношение порядка (Comparable, Sortable). Такие классы всегда отложены (абстрактны) и часто реализуются как интерфейсы, если конкретный язык программирования это позволяет.



## Аргументы (параметры) методов
Общий принцип: чем меньше аргументов у метода, тем лучше. В идеале АТД желательно спроектировать так, чтобы у каждого метода, подразумевающего параметры, был ровно один аргумент.

Аргументы делят на два класса: операнды и опции.

Операнды -- это непосредственные значения (объекты), требуемые для работы метода.

Опции определяют различные режимы работы метода. Опции практически всегда можно задавать значениями по умолчанию.

Аргументы команд -- всегда только операнды.

-- Задание опций для команд выполняется отдельными вспомогательными командами, для которых эти опции уже будут операндами, причем эти команды имеют ровно один аргумент.
-- Названия вспомогательных команд выдерживаются в едином стиле, например, set_ИмяСвойства().
-- Если аргумент -- логическое значение, лучше создать две команды без аргументов, одна из которых устанавливает соответствующее свойство в true, а другая в false. Например, set_light_on() и set_light_off().
-- Для каждой команды, задающей некоторую опцию, должен иметься запрос, возвращающий текущее значение этой опции.
-- В общем случае в коде явно устанавливаются только те опции, которые отличаются от настроек по умолчанию.

При таком подходе не требуется запоминать все детали настроек различных команд, а при расширении класса новыми возможностями его основной интерфейс остаётся неизменным, добавляются как правило только инструкции установки новых опций. Вдобавок одни и те же опции могут использоваться разными командами, и при этом не потребуется многократно их указывать в аргументах этих команд, а достаточно установить один раз, или до следующего вызова соответствующей команды установки соответствующей опции.

Исключения из этого правила делаются обычно в двух случаях:
1) для методов, создающих новые объекты, в любом случае должен присутствовать метод, в котором все опции имеют значения по умолчанию (подразумевается конструктор по умолчанию);
2) для методов, где по смыслу желательно указывать не только опцию, но и основной аргумент (например, строковое имя какого-то устройства), хотя в таком случае оба таких параметра будут операндами.


## Геттеры/сеттеры
Мы собираемся явно разделять запросы и команды, но полностью отказываемся от любых общедоступных атрибутов, полей класса. Ведь мы можем и получать значение атрибута, и одновременно изменять атрибут через прямое обращение к его имени (присваивание), что полностью противоречит нашему подходу. Упомянутый выше универсальный синтаксис вызова методов потенциально допускает схожее с функциональным указание идентификатора атрибута для получения его значения -- как условную функцию без аргументов и даже без скобок списка параметров (), однако никак не поддерживает вариант с присваиванием атрибуту значения.

Существует известная практика геттеров/сеттеров, когда для считывания значений атрибутов используются методы getИмяАтрибута(), а для изменения их значений -- методы setИмяАтрибута(). Этот подход далеко не самый лучший: во-первых, приходится создавать множество маленьких методов, во-вторых, их наличие всё равно даёт неограниченные возможности по изменению значений атрибутов.

Но самое главное, что атрибуты/поля никак не представляются в АТД, и мы добавляем в АТД обычные запросы и команды как некие аналоги геттеров/сеттеров только в случаях, если они действительно необходимы, и им есть определения в спецификации.


## Синглетоны
В заключение ещё один важный момент. Некоторые классы подразумевают свою единственную реализацию: разрешается создавать только один экземпляр такого класса. Это вполне допустимый подход. Реализуется подобная схема с помощью так называемого шаблона проектирования Одиночка/Синглетон, или с помощью Фабрики объектов. Например, когда мы моделируем работу конкретного города, в системе потребуется ровно один экземпляр класса Город.

# Организация модулей в проекте

Ранее упоминался принцип, согласно которому класс -- это и тип данных (семантическая единица проекта), и модуль (синтаксическая единица проекта). Однако линейная схема проекта, в котором могут быть сотни и тысячи классов, плохо подходит для наглядного представления. Поэтому классы обычно группируются в так называемые кластеры. Каждый кластер объединяет классы, связанные общим смыслом (например, компоненты пользовательского интерфейса, или элементы библиотеки для работы с сетью).

Однако кластер -- это не какая-то особая самостоятельная, автономная сущность для структуризации проекта, а всего лишь удобный способ управления кодом. Кластер может реализовываться, например, виртуальными папками среды разработки или физическими каталогами операционной системы. Но единственной модульной единицей в проекте всегда остаётся только класс.

Кластер может включать в себя другие кластеры, но не может включать одновременно и кластеры, и классы (разрешается либо только то, либо только то).

К кластерам не предъявляются особые формальные требования, создание кластеров -- это ответственность прежде всего руководителя проекта или архитектора системы. Единственная рекомендация заключается в том, что в кластере должно быть не более 40 классов (и как правило, не менее 5 классов), и уже при наличии 20 классов желательно начинать разделять кластер на подкластеры. Обычно реализацией одного кластера занимается тоже один конкретный разработчик.


## Legacy (унаследованный код)
Сколь бы старательно мы не продумывали заранее классы и АТД, со временем требования к системе обычно меняются, и подчас весьма сильно.

В ситуации, когда назрела необходимость изменения АТД и, соответственно, интерфейса класса, его реализующего, есть два возможных решения:
1) не менять интерфейсы, что не позволит улучшить систему, а в дальнейшем будет приводить к ухудшению ситуации в целом;
2) изменить интерфейсы, что может существенно усложнить работу нынешних пользователей, но в дальнейшем приведёт к улучшению ситуации в целом. Это решение, в частности, обязательно, если в системе найдены ошибки.

Каждый вариант надо оценивать, исходя из множества особенностей конкретного проекта. В качестве компромиссного в индустрии программного обеспечения принят подход, когда подлежащие удалению возможности (например, классы целиком, или их отдельные методы) официально объявляются устаревшими, и при их использовании пользователи получают соответствующие уведомления. Но эти уведомления должны обязательно сообщать срок, когда поддержка устаревших компонентов полностью закончится.

# Реализуем класс Stack
Как лучше реализовать стек? Эффективнее всего это делать с помощью связного списка, где добавление и удаление элемента в его хвост выполняется за O(1). Но в нашем примере работа с таким списком, если соответствующий класс отсутствует в стандартной библиотеке языка, тоже потребовала бы отдельной качественной спецификации его интерфейса через АТД (связным списком мы займёмся позже).

Поэтому исключительно для наглядности реализуем стек на основе некоего условного "стандартного" списка (или динамического массива) List, параметризуемого типом. Такой список поддерживает отрицательную индексацию, начиная с хвоста (-1 -- это индекс последнего элемента в списке), а также методы удаления i-го элемента RemoveAt(i), добавления нового элемента в хвост Append() и получения количества элементов Length().

Конструктор мы оформим в общепринятом формате: хотя подразумевается, что вызов конструктора Stack() в классической записи

my_stack = new Stack()
создаёт новый объект (который конструкция new Stack() явно возвращает), однако внутри кода конструктора никаких инструкций создания объекта указывать не будем: подразумевается, что такой объект создаётся автоматически.

```csharp
class Stack<T>

  // скрытые поля
  private List<T> stack; // основное хранилище стека
  private int peek_status; // статус запроса peek()
  private int pop_status; // статус команды pop()

  // интерфейс класса, реализующий АТД Stack
  public const int POP_NIL = 0;
  public const int POP_OK = 1;
  public const int POP_ERR = 2;
  public const int PEEK_NIL = 0;
  public const int PEEK_OK = 1;
  public const int PEEK_ERR = 2;

  public void Stack() // конструктор
    clear()

  public void push(T value)
    stack.Append(value)

  public void pop()
    if size() > 0
      stack.RemoveAt(-1)
      pop_status = POP_OK
    else
      pop_status = POP_ERR

  public void clear()
    stack = [ ] // пустой список/стек

    // начальные статусы для предусловий peek() и pop()
    peek_status = PEEK_NIL
    pop_status = POP_NIL

  public T peek()
    if size() > 0
      result = stack[-1]
      peek_status = PEEK_OK
    else
      result = 0
      peek_status = PEEK_ERR
    return result

  public int size()
    return stack.Length()

  // запросы статусов
  public int get_pop_status()
    return pop_status

  public int get_peek_status()
    return peek_status
```