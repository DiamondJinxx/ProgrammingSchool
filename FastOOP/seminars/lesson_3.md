# 3. Оборачивайте все стандартные примитивные и строковые типы в прикладные типы/классы.

Главная идея: **запретить прямую модификацию состояний (через свободный доступ к переменным), инкапсулировав их, в идеале, в абстрактные типы данных (АТД)** c переходом к декларативной модели программирования.

Что понимать под примитивными типами данных? Ну, если придерживаться строгих методик проектирования вроде Domain-driven design (DDD), **любой тип в вашей программе, который был написан не вами, считается примитивным**, потому что он не входит в предметную область вашего проекта.

Например, в языках Java или Python тип int -- это примитив, а не реальный объект, поэтому он подчиняется другим правилам, нежели объекты. **Для работы с ним применяется синтаксис, который не является объектно-ориентированным.** Что ещё более важно в критическом плане, int сам по себе просто абстрактное скалярное значение. Когда метод получает int в качестве параметра, тело метода должно сделать всю работу по использованию int в правильной семантике проекта -- вложить в int тот смысл, который подразумевает программист.

Если же этот метод принимает в качестве параметра например объект пользовательского типа (класса) Hour, то гораздо проще понять, что происходит, а набор операций Hour не позволит выполнить над аргументом заведомо ошибочные логические манипуляции. Да и сам аргумент по определению всегда будет находиться в корректном состоянии, а не то что дата вдруг стала числом -1.

Кроме того, вы уже не сможете случайно передать такому методу параметр типа Year, вас сразу остановит компилятор. А при обычном использовании примитивных типов он никак не сможет вам помочь в написании семантически корректной программы. Фактически, **вы предоставляете компилятору (и программистам) дополнительную информацию о том, что это за значение, и для чего оно используется, что обычно легко понимается через описание типа.**

Кроме того, небольшие типы Hour или Money дают вам очевидное физическое место в проекте для размещения поведения, которое в противном случае было бы разбросано по другим классам. Этот подход становится особенно актуальным, когда вы доберётесь до правила 9.

Данное правило -- по сути, декомпозиция паттерна **Value Object из DDD, который подразумевает создание прикладных типов для простых объектов в программе** (деньги или диапазон дат), равенство которых в частности не основано на простой проверке идентичности значений. Например, деньги одной и той же величины могут быть в разных валютах, а даты -- в разных таймзонах, которые нельзя сравнивать в лоб, компилятор сообщит об ошибке. А если использовать примитивные типы для хранения денег в целых "штуках", или времени в секундах unix, не миновать беды.

Я ещё очень рекомендую добавить из Value Object такую фичу, как **иммутабельность (неизменяемость) простых объектов.** Например, если вы создали экземпляр класса Money с ярлыком "1000 рублей", вы не можете изменить его значение 1000 например на 500 :) Значения типа Money можно складывать или вычитать конечно, но аргументы этих операций неизменны, в результате мы получаем новый объект с итоговым значением. И если получается например отрицательное число -100 рублей, очень удобно контролировать корректность по флагу ошибки объекта.

Дополнительное понимание данного пункта может быть в форме способа обхода анти-паттерна [Primitive Obsession](https://arc.net/l/quote/hzunehid).

Аналогичное правило применяется и к строкам, если программа непосредственно не занимается обработкой строк или их символов. Например, в коде используются повторяющиеся строки-сообщения -- как минимум, их надо оформить как константы, а если они представляют собой некоторые идентификаторы, то их надо представить в виде класса, где каждый идентификатор ограниченно доступен, например, по своему номеру. Этот подход, в частности, поможет избавиться от классических проблем, связанных с кодировкой текстовых сообщений, которые теперь аккуратно собираются в одном месте по смыслу, и в целом, с локализацией.

**Разработка, управляемая типами (Type driven development)** -- это и сегодня, и особенно в ближайшем будущем, по мере развития систем типов в языках программирования, абсолютный топ в информатике. Типы данных в вашем проекте (классы в ООП) -- это фактически и есть тот язык, на котором вы разговариваете с другими разработчиками и с заказчиками.

Резюме пункта 3: если у вас в программе имеются любые вычисления, логически явно отличные от прямых арифметических расчётов с целыми или вещественными числами (частый пример -- использование целых для денежных расчётов) и прямых манипуляций с другими примитивными типами, **то вместо чисел или строк надо использовать пользовательские типы (классы) с соответствующим набором операций и встроенным контролем корректности и допустимости действий.**
