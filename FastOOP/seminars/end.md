# Object Calisthenics (чек-лист)

1. Пишите функции/методы так, чтобы внутри них было не более одного отступа.
   В вашем коде не должно быть вложенных циклов и вложенных условий.

2. Не используйте else и сокращенные формы else if (elif, ...).

3. Оборачивайте все стандартные примитивные и строковые типы в прикладные типы/классы.

4. Оборачивайте коллекции первого класса в пользовательские типы/классы.

5. В одной строке кода не более одной "точки" (отказ от цепочек вызовов методов).

6. Не сокращайте имена классов/методов/функций.

7. Сохраняйте все сущности в проекте (синтаксически) маленькими.

8. В классе должно быть не более двух полей (атрибутов).

9. В классе не должно быть геттеров/сеттеров, а все поля обязательно приватно инкапсулируются.

# Дополнительная информация по курсу

Семь из девяти правил по сути просто способы визуализации и реализации святого Грааля объектно-ориентированного программирования -- **инкапсуляции данных.**

Одно из основных понятий ООП -- **абстракция**: класс должен отражать одну и только одну ключевую абстракцию (SRP). Очевидно, что примитивные и встроенные типы лишены абстракции в контексте вашего проекта. "Обёртывание" примитивов (правило 3) и "обёртывание" коллекций (правила 4 и 8) подталкивает вас к созданию большего числа абстракций. А чтобы они не плодились бессмысленно, правило 6 помогает сфокусировать ваши абстракции на предметной области проекта.

Правильные классы (АТД) определяются тем, что они делают, а не тем, что они содержат. **Все данные должны быть спрятаны внутри своего класса.** Это и есть инкапсуляция. Правило 9 заставляет вас держаться подальше от доступа к полям за пределами класса.

Кроме того, ещё одно правило 2 управляет надлежащим использованием **полиморфизма**: не используем else и вообще сводим к **минимуму** всю условную логику, перекладывая её на компилятор и среду времени выполнения. И наконец правило 6 -- стратегия именования, поощряющая краткие и понятные стандарты для имён, без непоследовательного применения и труднопроизносимых сокращений.

Сермяга данной методики заключается в том, чтобы **создать программу, в которой нет дублирования кода ни на уровне синтаксиса, ни на уровне семантики.** Вы пишете код, который лаконично выражает простые и элегантные абстракции.

Довольно детская критика от "умельцев" мэйнстрима обычно сводится к весьма слабым утверждениям наподобие такого: каждый шаг, который вы делаете в направлении "истинного ОО" по данным правилам -- это очередной способ затушевать смысл вашего кода. Если вы разбиваете свой код на 10 различных методов, то это 10 различных мест, куда вам придётся заглянуть, чтобы понять, что происходит. Вы как бы пишете спагетти-код под другим названием. При этом авторы критики сами признают, что если вы создаете большой проект, то, возможно, дополнительная гибкость того стоит :)

Ну конечно, во-первых, если вы пишете маленький проект, утилиту или скрипт, наверное проще и быстрее написать линейный код. Мы же говорим прежде всего о взрослых серьёзных проектах.

Во-вторых, и это самое главное, я не раз объяснял в заметках в паблике, что как раз невозможно продуктивно мыслить о программе, о смысле кода, на уровне самого кода, на непосредственном уровне инструкций. Нам как раз нужны гораздо более сильные логические абстракции, которые можно вместе удерживать в голове, но языки программирования нам такой возможности не предоставляют. Методики вроде DDD нацелены именно на это. Девять правил как раз сильно упрощают процесс думания о проекте в терминах его предметной области.

Чтобы получить реальный эффект от Object Calisthenics, **потратьте не менее 20 часов и напишите не менее 1000 строк кода, который на 100% соответствует этим правилам.** Вы обнаружите, что вам придётся отказываться от немалого числа старых привычек и изменять правила кодирования, с которыми вы, возможно, жили всю свою жизнь разработчика. И это конечно будет дискомфортно :)
Но, стараясь постоянно следовать всем этим правилам без исключений, вы естественным образом измените в лучшую сторону ваш стиль кодирования и проектирования -- то, как вы пишете код и как формируете систему типов/классов.

Надо ли применять эти правила все вместе, или можно попытаться "улучшить" эту методику, подойти к ней "творчески", взять только некоторые пункты, а другие не брать, или внести в них правки на свой вкус?

**Я настоятельно рекомендую применять эту методику целостно, не исключая ни один пункт, и ничего в них не меняя** -- потому что вы наверняка будете отказываться прежде всего от тех пунктов, которые для вас наиболее трудны, и именно поэтому дадут вам наибольшую пользу.

Конечно, по мере практики вы скорее всего обнаружите, что эти правила противоречат друг другу в некоторых исключительных ситуациях, или их применение приводит к вырожденным результатам. Это совершенно нормально, это частные случаи, и я уверен, что со временем вы поймёте, как, оставаясь в рамках данной методики, их можно обойти.

Каждое из этих правил было выбрано таким образом, что если вы будете следовать ему без отклонений, вы начнёте добираться до ситуаций, которые обычно имеют простой но контринтуитивный ответ, который вам ранее был недоступен.

Чем больше вы практикуетесь в применении правил, тем больше преимуществ получаете. Ваши первые попытки реализовать проект в в предложенном здесь стиле окажутся неловкими и скорее всего не приведут к ощутимому выигрышу, но поверьте, это временно. Применение правил -- это искусство и дисциплина программирования, поднятые на другой уровень.

Дисциплинированное следование всем правилам Object Calisthenics принудит вас постепенно находить всё более сложные ответы, которые ведут к гораздо более глубокому пониманию объектно-ориентированного программирования. Если вы напишете тысячу строк, которые следуют всем этим правилам, вы обнаружите, что создали нечто совершенно иное, нежели вы ожидали исходно и нежели вы получили бы, вымучивая классическими навыками "сознательного" проектирования.

Просто следуйте правилам (я бы даже сказал -- следуйте механически, не слишком увязая в медленном мышлении -- делайте это легко), и посмотрите, к чему вы в итоге придёте. Если то, что получится, вас не устроит, отступите и посмотрите, что вы можете сделать более удобным. Скорее всего, если вы продолжите работать над проектом по этим правилам, вы найдете то, что нужно.

И в конечном итоге вы увидите, что код, который вы пишете, соответствует всем этим правилам без каких-либо сознательных усилий с вашей стороны.

Это будет ваша очередная победа в ООП и ОО-проектировании.

Перед третьим, прикладным курсом по ООАП:

1. Изучите материал СильныхИдей "94) ООП как средство повторного использования кода".

2. От курсанта:
   "По ООП проектированию у меня затык насчёт ситуации, когда в условной игре пользователю нужно выполнить команду. Но команды бывают условно "высокоуровневые" - закончить игру, перезапустить и т.д. И "низкоуровневые" - например, манипуляции с элементами игрового поля. Если мы придерживаемся подхода с не больше 2-х полей в классе, и не допускаются "цепочки" вызовов, то как команде "дотянуться" одновременно до объекта сервиса игры и до конкретного элемента игрового поля. Здесь нужен либо какой-то паттерн (пока не уверен какой), либо разные иерархии классов на такие команды."

Да, предварительно изучите паттерны Фасад, Observer и Command.
