# 9. В классе не должно быть геттеров/сеттеров, а все поля обязательно приватно инкапсулируются.

Это крайне полезное заключительное правило, которому я учу ещё на самом первом курсе для начинающих, нацелено на объектное мышление на более высоком уровне абстракции -- АТД. Данное правило, в частности, запрещает использование публичных полей, что само по себе отличная идея.

Это уточнение закона Деметры, гласящее, что вы можете использовать геттеры/сеттеры только внутри класса, не позволяя им выходить наружу.

По сути, мы запрещаем любой внешний доступ к внутреннему состоянию объекта, что очень правильно соответствует подходу АТД, когда у сущности должны быть только те операции, которые относятся к этой сущности по смыслу предметной области. Например, если есть АТД Кот с операциями Бегать и Кушать, то с какой стати давать доступ к его внутреннему полю Масса, если в проекте требуются лишь эти две операции? Это нарушение и принципа единственной ответственности, и принципа Open/Close: создавая сеттеры например, мы открываем класс для модификаций, что совсем плохо -- он должен быть открыт лишь для расширения через наследование.

В этой связи отмечу, в дополнение к SOLID, ещё один очень полезный принцип: **не спрашивайте класс о чём-то, а говорите ему, что делать -- отдавайте ему приказы.** Этот принцип исключает геттеры, которые по сути отвечают на внешний вопрос. Можно конечно создавать геттеры в случаях, если от АТД явно это требуется: например, UI требует показывать массу кота. Но даже в таком случае это должен быть не стандартный геттер, а метод с именем, явно указывающим, что масса нужна именно (и только) для показа в интерфейсе пользователя.

Почти напрямую ведет к этому правилу, как ни парадоксально на первый взгляд, предыдущее правило (не более двух полей в классе). Если текущей конструкцией ваших классов всё ещё неудобно пользоваться, надо рассмотреть прямые нарушения инкапсуляции. Поведение не будет следовать за объектом, если можно просто запросить его внутреннее значение, текущее состояние.

**Идея сильной инкапсуляции заключается в том, чтобы заставить программистов искать и находить некоторое единое по смыслу поведение и помещать его в одном конкретном месте в объектной модели.** В результате же возникает множество полезных эффектов: от сокращения ошибок, связанных с дублированием кода, до удобной локализации вносимых в проект изменений при реализации новых возможностей.

Тут может возникнуть хороший вопрос. Поскольку мы обернули все примитивные типы в пользовательские классы (правило 3), и у нас нет геттеров, мы никогда не сможем выяснить их значения, их состояние. **Так как же нам тогда создавать юнит-тесты, проверяющие состояние, ведь такие тесты очень полезны?**Это действительно довольно сложный момент, и однозначного решения тут нет. Например, добавлять геттеры в рабочий класс только ради тестов, конечно, будет плохим решением.

Во-первых, надо понять, **зачем вам вообще понадобилось проверять состояния внутренних полей?** Если это требуется не только для тестов, значит, проблемы с проектированием, надо пересмотреть иерархию классов, насколько она отражает предметную область.

Во-вторых, если это требуется именно для тестов, **можно добавить в класс операцию сравнения объектов по их внутренним значениям**, что будет несложно, так как в классах теперь не более двух полей.

В-третьих, можно задействовать наследование, и **создать классы-наследники тестируемых сущностей**, специально для тестов -- только с геттерами.

Как правило, подобные отладочные расширения проекта можно регулировать различными инструкциями препроцессора, легко включая или отключая дополнительный код.
