# 8. В классе должно быть не более двух полей (атрибутов).

Это действительно довольно суровое, в чём-то экстремальное на первый взгляд правило принуждает вас тщательно задумываться о композиции и наследовании и приводит в итоге к снижению внешней связанности (coupling), повышению внутренней связности (cohesion) и лучшей инкапсуляции.

Например, если вы хотите запихать в класс Customer три поля: Id, FirstName и LastName, то вполне логично будет объединить FirstName и LastName в отдельную логическую сущность (класс) Name из двух полей. Если составляющих в имени больше двух (например, три -- есть ещё отчество), явные именованные поля можно заменить на одно поле-коллекцию, внешний доступ к элементам которого будут выполнять наглядно именованные геттеры. В такой ситуации, кстати, мы автоматически применяем правило 4: создаём обёртку для стандартной коллекции, которая выступает единственным полем класса Name, предоставляя естественные операции именно для работы с ФИО пользователя.

Что интересно, тут чаще всего не жалуются на строгость данного правила, а спрашивают "почему не более двух, а не более трёх атрибутов"? Ответ: "а почему нет?" :)

Во-первых, два -- **минимально возможное количество атрибутов, допускающее последующую декомпозицию** (только один атрибут в классе, моделирующем сложную сущность, очевидно, бессмысленен). **Из-за своей минимальности данное правило принуждает вас часто разделять классы.**

Во-вторых, **хорошая идея семантически разделять два вида классов**: те, которым достаточно одного атрибута -- фактически это явная работа с конкретным состоянием, и те, которые координируют активность двух разных сущностей.

В-третьих, **формировать и сопровождать классы с двумя полями гораздо проще**, нежели с большим количеством атрибутов.

В-четвёртых, **ограничение в два поля принуждает вас активнее применять методы функционального программирования** и больше усилий вкладывать в чистую логику, нежели в манипуляции состояниями.

Иногда может казаться, что выделить в сущности только два ключевых атрибута примерно одного логического уровня часто будет невозможно, но на самом деле это почти всегда не так, за исключением совсем экзотических случаев. Даже в случае явной равноправности -- например, четыре точки в классе прямоугольника left, top, right, bottom вполне можно представить двумя left_top и right_bottom (вы спрашиваете, а если это пентагон? тогда используйте массив фиксированного размера, или список и смоделируйте обобщённый n-угольник).

Или, например, класс Автомобиль, в котором "содержится" руль, четыре колеса, несколько фар, двигатель, медиасистема, и ещё много всего другого? В данном случае вот так "напихивать" совсем разные смысловые сущности на один уровень как раз совсем плохо. Вы понимаете, почему?

Хороший приём -- делить класс на два по принципу "форма и содержание". В случае с автомобилем правильнее будет сгруппировать все эти сущности в два класса "Ходовая часть" и "Кузов" или во что-то другое подобное. Но сделать это можно практически всегда.

По многочисленному опыту прикладных проектировщиков, **декомпозиция класса из линейного набора атрибутов в иерархию взаимодействующих объектов практически всегда и нередко довольно неожиданно ведёт к гораздо более естественной и эффективной объектной модели.** В противном случае вы потратите много часов, пытаясь проследить потоки данных через большие объекты. Можно конечно выудить объектную модель из этого всего, но это будет очень кропотливый процесс, когда надо как следует понять связанные группы поведений и сформулировать результат их совместного взаимодействия, а получится скорее всего что-то хоть и работающее, но сложное и запутанное.

А вот рекурсивное применение данного правила приводит к очень быстрой декомпозиции больших и сложных объектов на гораздо более простые модели. Что важно, и итоговое поведение такой иерархии естественным образом укладывается в моделируемую предметную область.
