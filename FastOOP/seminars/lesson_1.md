# 1. Пишите функции/методы так, чтобы внутри них было не более одного отступа.

Семантически это означает: не допускайте никаких дополнительных вложений в циклы и условия кроме их непосредственных "тел".

В вашем коде не должно быть вложенных циклов и вложенных условий.

Главная идея: снижение цикломатической сложности и, соответственно, упрощение сопровождения кода. Кроме того, сильно возрастает выразительность и понимаемость кода и повторность использования методов.

Вы когда-нибудь смотрели на большую и плохо работающую легаси-функцию, не представляя не то что "с чего начать", а вообще, "как бы к ней вообще подступиться"? **Большим функциям и методам сильно не хватает внутренней связности.**

Про правильный размер функций/методов будет также пункт 7. В частности, есть такая чрезмерно формальная синтаксическая рекомендация -- ограничивать длину каждого метода пятью строками, (при этом у вас и не получится уместить вложенные инструкции управления в такой микро-объём), но если класс будет завален 500 короткими методами, такой переход будет пугающим.

Вместо этого постарайтесь сделать так, чтобы **каждый метод выполнял ровно одно действие, решал ровно одну задачу.** В идеале, включайте одну управляющую структуру или один условный блок на метод. В принципе, вполне допустима и линейная последовательность таких одноуровневых инструкций, эту фундаментиальную схему мы проходим на курсе по декларативной парадигме программирования.

**Если у вас появляются вложенные управляющие структуры, это значит, что вы пытаетесь работать уже на нескольких уровнях абстракции**, а это в свою очередь значит, что вы заставляете метод делать больше, чем одну вещь.

И поскольку вы работаете с методами, которые делают ровно одну вещь и реализованы внутри классов, тоже делающих ровно одну вещь (см. пункты 6 и 7), ваш код начинает магически менять свою структуру. **По мере того, как каждая сущность в вашем проекте становится меньше, уровень их повторного использования начинает расти экспоненциально**. Будет трудно обнаружить возможности для повторного использования метода, который имеет пять обязанностей и реализован в 256 строках, а вот метод из трёх строк, который управляет состоянием объекта в определенном контексте, обычно получается использовать и во многих других различных контекстах.

Каждый отдельный метод становится практически тривиальным, и его реализация становится полностью соответствующей его имени (см. пункт 6). Да и выявить ошибки в таких гораздо меньших фрагментах кода как правило намного проще.
