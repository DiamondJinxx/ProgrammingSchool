# 4. Оборачивайте коллекции первого класса в пользовательские типы/классы.

В принципе, этот пункт изоморфен предыдущему, идея та же, только применительно к коллекциям (массивы, списки, словари... из стандартных библиотек). Отдельный пункт создан потому, что имеется некоторая техническая специфика.

Стандартные коллекции обычно предоставляют программисту излишнюю свободу (например, возможность одной командой удалить всё содержимое коллекции, или обратиться к ней с некорректными индексом, вызвав прерывание, и т. д.), поэтому их использование в конкретной задаче имеет смысл ограничить только компактным набором тех операций, которые действительно требуются, добавив что-то непосредственно по теме задачи (например, специфичные операции фильтрации или поиска). Для этого соответствующая коллекция погружается в АТД.

Как уже говорилось, мы избегаем использования в проекте любых стандартных, готовых типов "из коробки" стандартной библиотеки.

Например, классическая беда с доступом к индексированному массиву в том, что это по сути операция доступа к данным по указателю, который легко сделать ошибочным (-1 или за пределами диапазона массива).

Технически это реализуется таким правилом, что **любой класс, использующий (содержащий) коллекцию объектов, не должен иметь никаких других полей.** Тогда автоматически получается, что каждая коллекция в проекте оборачивается в свой собственный класс, и любое поведение, связанное с коллекцией, имеет своё конкретное местонахождение в проекте.

Вы можете например добавить операции фильтрации в такой класс, объединения двух коллекций вместе, применения функции к каждому элементу коллекции, различные команды агрегации значений и т. п.
