# 10. Параллелизм (одновременное выполнение, concurrency)

В современном программировании часто требуется, чтобы программа содержала несколько самостоятельных активностей, каждая из которых выполняется в своём темпе. Этот принцип будем называть для удобства параллелизм -- в смысле одновременного выполнения (concurrency, программная поддержка одновременной работы).

Между активностями не должно быть никаких взаимных помех. Они исполняются абсолютно независимо друг от друга, если только программист не решит каким-то явным и корректным образом организовать их взаимодействие.

Введём понятие параллелизма через нить, тред (thread). Нить -- это обычный выполняющийся код. В предыдущих примерах мы писали небольшой код и запускали программу, последовательно выполнявшую разные функции (это была одна нить).

После введения концепции одновременной работы программе допускается поддерживать более чем одну нить, каждая из которых работает одновременно с другими нитями, и в то же время полностью независимо от других нитей.

Julia поддерживает несколько моделей параллельных вычислений (требуется версия не менее 1.5.0), но чтобы этот режим заработал, надо запустить компилятор с параметром "--threads n" , где n -- количество одновременных нитей, не менее 2. Например:

```
julia --threads 4
```

По умолчанию Julia работает с одной нитью; текущее количество максимально доступных нитей в вашей системе выдаёт функция Threads.nthreads().

Идентификатор текущей нити, начиная с 1 (главный процесс, основная программа), выдаётся функцией Threads.threadid(). На практике идентификаторы N нитей укладываются в диапазон 1..N, однако полагаться на этот нюанс не стоит.

# 10. Параллелизм (2)
Самая простая модель concurrency в Julia подразумевает использование макрокоманды Threads.@threads , которая задаётся перед оператором цикла for. В итоге каждое выполнение тела этого цикла автоматически "разбрасывается" между нитями, причём никакого подразумеваемого порядка такого разбрасывания в принципе не существует.

Обычный код

```
for i = 1:10
    println("i = $i on thread $(Threads.threadid())")
end
```
естественно выведет

```
i = 1 on thread 1
i = 2 on thread 1
i = 3 on thread 1
i = 4 on thread 1
i = 5 on thread 1
i = 6 on thread 1
i = 7 on thread 1
i = 8 on thread 1
i = 9 on thread 1
i = 10 on thread 1
```
Программа выполняется в одной мастер-нити (идентификатор 1).

Переведём этот цикл в параллельный режим:

```
Threads.@threads for i = 1:10
    println("i = $i on thread $(Threads.threadid())")
end
```

Теперь результат скорее всего будет каждый раз случайным, например:

```
i = 9 on thread 4i = 4 on thread 2

i = 1 on thread 1
i = 5 on thread 2i = 10 on thread 4

i = 6 on thread 2
i = 7 on thread 3
i = 8 on thread 3
i = 2 on thread 1
i = 3 on thread 1
```

Почему так происходит? Потому что механизм распараллеливания выполняет код из соображений эффективности. Программисту при написании прикладного кода правильнее всего полагать, что все повторения тела цикла выполняются одновременно. Иначе возникают вышеописанная проблема, называемая обычно проблемой race conditions.

На практике возможно например, что будут задействованы не все нити, или какие-то нити значительно активнее, нежели другие. Программиста это не должно заботить в том плане, что он исходно обязан учитывать, что никакой последовательности выполнения "тел" параллельного цикла не существует, и можно лишь быть уверенным в том, что тело выполнится нужное количество раз.

Кроме того, операции ввода-вывода из-за необходимости взаимодействия с периферийными устройствами, которые нередко используют свои аппаратные буферы, могут выполняться не совсем так, как ожидается. В данном случае видно, что хотя вывод всей строки выполняется всегда корректно, однако переход на новую строку иногда сбивается: результат работы следующей нити выводится быстрее, нежели перевод строки, отправленный терминалу из предыдущей нити.

# Ссылки/указатели в Julia

Промежуточное отступление про ссылки/указатели в Julia, которые понадобятся в дальнейшем.

В Julia поддерживается работа с безопасными ссылками, гарантирующими как корректность данных, на которые они указывают, так и автоматические выделение и очистку памяти. Причём указатели допускаются не только на пользовательские объекты и данные сложных типов, но и на значения базовых типов.

Функция Ref() возвращает внутреннюю ссылку на объект-параметр. Если в качестве аргумента задаётся значение базового типа (например, целое число), Julia автоматически выполнит его размещение в памяти, и Ref() вернёт корректную ссылку на соответствующую "ячейку".

Например, Ref(1) разместит в памяти значение 1 целого типа, и вернёт ссылку (указатель) на это значение:

```
pnt1 = Ref(1)
```
В дальнейшем можно как считывать значение, доступное по ссылке, так и менять его. Для этого используются скобки [] , указываемые непосредственно за именем переменной-указателя.

```
pnt1 = Ref(1)
println(pnt1[]) # 1

pnt1[] = pnt1[] + 11 
println(pnt1[]) # 12
```