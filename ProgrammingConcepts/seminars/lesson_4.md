# 4.1. Списки
Списки -- более сильная абстракция, нежели массивы, которые, как правило, лучше знакомы программистам на статически типизированных языках. Мы приходим к спискам естественно, как только возникает потребность вычисления и обработки последовательностей чисел и значений других типов. Классический пример -- это последовательность Фибоначчи, когда каждый следующий элемент равен сумме двух предыдущих.

Типа данных "список" (как в Python например) в Julia нету, однако синтаксис типа данных "массив" похож на синтаксис списка. В частности, в Julia допускается массив, содержащий элементы разных типов; мы будем трактовать его как "универсальный" список, без особой привязки к специфике Julia.

Условный список в Julia -- это последовательность элементов произвольных типов, перечисленных через запятую, в квадратных скобках.

```
[1,2,3,5,8]
x = [] # пустой список
```
Внутри список (не конкретно в Julia) обычно реализован как цепочка узлов, где каждый узел состоит из хранилища значения узла и ссылки на следующий узел. Формально списки формируются добавлением строго по одному элементу (хотя имеются стандартные функции, позволяющие добавлять сразу несколько элементов, но внутри они фактически итерируют список добавления и добавляют по одному элементу), начиная с пустого списка [], и последующим добавлением узлов друг за другом.

Новый узел записывается как H|T, где H -- значение нового элемента, и T -- оставшаяся часть цепочки узлов. Например, начинаем со списка Z=[]. Добавляем первый узел Y=7|Z, и затем второй узел X=6|Y. Теперь X ссылается на список из двух узлов, который может быть записан как [6, 7].

Узел H|T часто называется cons -- термин, который пришёл из языка Лисп.

В Julia добавление значения в голову списка записывается так:

```
Z = [6, 7]
pushfirst!(Z, 5) # Z == [5,6,7]
```
Символ ! в конце функции добавления означает, что она модифицирует значение своих аргументов (в данном случае, изменится значение списка Z). По умолчанию все аргументы передаются в функции Julia по ссылке, если позволяет их тип.


# 4.2. Списки (2)
Первый элемент списка называется голова (head). В Julia его можно получить обычным обращением к списку с индексом.

Индексация массивов в Julia начинается с 1, не с 0.

```
Z = [5,6,7]
Z[1] # 5
```
К последнему элементу массива можно обратиться с помощью условного индекса end:

```
Z[end] # 7
Z[end - 1] # 6
```
Оставшаяся часть списка без головы называется хвост (tail). Удалить из списка его голову (оставить хвост) можно командой

```
popfirst!(Z) # Z == [6,7]
```
Сцепление списков (добавление второго списка в хвост первого списка) выполняет команда append!

Добавление элемента в хвост списка выполняет команда push!

Создание массива длиной N вещественных чисел, заполненного нулями, выполняет команда zeros:

a = zeros(N) 


# 4.4. Сопоставление с образцом (Pattern matching)
Эта мощная классическая техника, своеобразная замена условным операторам, подразумевает проверку некоторого значения по набору шаблонов, и в случае совпадения -- разбор по подходящему шаблону. В оригинальной Julia она реализована в ещё более сильной форме (сопоставляются не значения, а типы), но это тема за пределами данного курса.

Некоторую классическую версию сопоставления с образцом можно добавить в Julia, установив пакет Match.jl. Для этого надо запустить среду Julia, и в командной строке поочерёдно ввести две команды:

```
using Pkg
Pkg.add("Match")
```
Pkg -- это встроенный менеджер пакетов Julia (очень удобный). Он автоматически скачает и добавит пакет Match (надо будет подождать несколько минут).

Пакет Match предлагает свой собственный дополнительный синтаксис, не будем погружаться в его детали, рассмотрим такой пример:

```
using Match
@match([1,2,3], [a, b...])
```
Команда using подключает в программу пакет, не входящий в стандартную поставку Julia.

Команда @match выполняет сопоставление значения из левой части (список [1,2,3]) с шаблоном из правой части [a, b...]. В данном случае он подразумевает выделение первого элемента "a" в списке, и оставшийся список-хвост "b..." (в переменной b).

В последней версии Match поддерживается уже другой синтаксис:

```
@ismatch [1,2,3] [a, b...]
```
В результате сопоставления значения с таким шаблоном/образцом в переменную "а" запишется число 1, а в переменную "b" -- оставшийся список [2,3].

Сопоставление с образцом часто применяется не только для анализа списков, но и как очень мощная замена операторам if/switch, поэтому рекомендую изучить, как эта технология поддерживается в языке программирования, которым вы активно пользуетесь.

