# 9. Программирование высшего порядка

Что, если мы хотим получить от lazy последовательность не идущих подряд чисел, а по какой-то иной, гораздо более сложной или нелинейной закономерности? Например, через одно, или удваивающиеся значения? Делать для каждого такого случая отдельную функцию неудобно и громоздко.

Хотелось бы иметь одну универсальную, обобщённую версию генератора последовательностей. Её можно сделать, передав функцию, вычисляющую следующее значение, как аргумент нашей функции lazy. Вот такая способность передавать функции в другие функции через их параметры -- когда функции сами выступают значениями -- и называется программирование высшего порядка
(в русскоязычной программистской литературе более распространён термин "функции высшего порядка").

Мы хотим передавать в lazy некоторую функцию, которая будет вычислять следующее значение последовательности произвольным способом на основании текущего значения. Для этого достаточно указать ещё один параметр lazy, который, подразумевается, будет функцией:

```
lazy(n, f) = @lazy n:lazy(f(n), f) 
```
Например, мы хотим вычислить последовательность, каждый следующий элемент которой в два раза больше предыдущего. Определим соответствующую функцию:

```
function f2(x) 
  return x * 2
end
```
И вызовем lazy (запросим первые пять значений, начиная с 7):

```
take(5, lazy(7, f2)) # List: (7 14 28 56 112)
```

# Циклы в Julia

Промежуточное отступление про циклы в Julia, которые понадобятся в дальнейшем.

Оператор цикла записывается так:

```
for счётчик in список или диапазон 
  тело цикла
end
```
Счётчик последовательно принимает значения из списка, например:
```
for s in ["one", "two", "three"]
   println(s)
end
```
Список чисел можно задавать начальным и конечным значением:

```
for n in 1:10
   println(n)
end
```
Цикл while будет выполняться, пока истинно его условие:

```
while условие
  тело цикла
end
```
Например:
```
n = 10
while n > 0
   println(n)
   n -= 1
end
```
Однако такой код в последних версиях Julia выполняться не будет. Дело в том, что этот мультипарадигмальный язык особое внимание уделяет профилактике типовых ошибок кодировщиков, по которым собрана огромная статистика. В частности, один из популярных багов -- когда значение некоторой переменной изменяется внутри цикла, и потом эта переменная используется в коде где-то позже, о чём программист забывает. Потому что, строго говоря, циклы, как и функции, как правило не предназначены для модификации "внешних" по отношению к ним переменных, и нужны прежде всего для "агрегации" индексируемых или итерируемых данных (например, расчёта суммы элементов списка). Но если локальные переменные, видимые только внутри функций -- это сегодня повсеместная практика, то локальные переменные, видимые внутри циклов, реализованы пока в немногих языках, включая теперь и Julia.

В данном примере в команде n -= 1 переменная n локальна внутри цикла while (переменная n из присваивания n=10 -- это глобальная по отношению к циклу переменная), поэтому когда выполняется команда n -= 1, возникает ошибка, так как локальная переменная n пока не имеет значения.

Поэтому, начиная с Julia 1.5, глобальным переменным внутри циклов надо задавать явную аннотацию global:

```
n = 10
while n > 0
   println(n)
   global n -= 1
end
```
