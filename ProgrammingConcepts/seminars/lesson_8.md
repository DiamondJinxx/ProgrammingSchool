# 8. Ленивые вычисления
Функции, которые мы делали выше, начинают работать сразу же, как только их вызвали. Эта схема называется энергичные или жадные вычисления.
Другой путь выполнения функций называется ленивыми вычислениями. В ленивых вычислениях функция начинает работу, только когда непосредственно затребован её результат.

В Julia ленивые вычисления поддерживаются пакетом Lazy. Добавьте его в систему:

```
using Pkg
Pkg.add("Lazy")
```
В простейшем случае, ленивые вычисления означают, что например элементы списка не будут вычисляться, пока они не затребованы непосредственно. Пакет Lazy вводит новый тип List (ленивый список), который сам по себе содержит базовые операции для классической работы со списками.

Например, список 1,2,3 с помощью этого ленивого типа запишется так:

```
using Lazy
x = list(1,2,3)
println(x) # List: (1 2 3)
```
Над списком возможны операции first (получить голову) и tail (получить хвост):

```
println(first(x)) # 1
println(tail(x)) # List: (2 3)
```

# 8. Ленивые вычисления (2)

Здорово, что в Julia разрешается запись списков в каноническом виде, как мы обсуждали выше:

H|T
(вместо "|" в Julia используется ":" ).
Например,
1:list(2,3)
означает список list(1,2,3).
При этом связок элементов ":" в такой записи списка может быть несколько, а между ними разрешается использовать не только константы, но и выражения, что сразу даёт нам мощный механизм формирования ленивых конструкций.

Например, мы хотим определить функцию, которая генерирует бесконечный ленивый список последовательных целых чисел, начиная с заданного. В компактной форме она запишется так:

```
lazy(n) = n:lazy(n+1)
```
Однако при её вызове, например, lazy(5) система вылетит с ошибкой времени выполнения -- переполнение стека. Это понятно: функция начинает сразу энергично генерировать бесконечный список, хотя пока им никто пользоваться не собирается.

Поэтому подключим модуль Lazy и инструкцией @lazy укажем, что вычисление должно проходить лениво:

```
using Lazy
lazy(n) = @lazy n:lazy(n+1)
print(lazy(5))
```
Мы мгновенно получим результат:

List: (5 6 7 8 9 10 11 12 13 14 15 ...)
      
где многоточие в конце намекает, что список бесконечный. На самом деле, конечно, он не вычислялся, а просто при запросе print() было сгененировано несколько первых значений.

В Julia существует специальная команда take, которая позволяет получить нужное количество значений от генератора таких бесконечных последовательностей (они обычно называются итераторы). Например, получить список из первых пяти значений:

```
println(take(5, lazy(25))) # List: (25 26 27 28 29)
```
