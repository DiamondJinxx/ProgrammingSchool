# 15. Недетерминизм и время

Мы разобрались, как добавлять в программу параллелизм и состояние по отдельности. Но если мы добавим обе эти возможности одновременно, программа от вызова к вызову может выдавать разные результаты на одних и тех же входных данных. Так случается потому, что нити могут получать доступ к состояниям в непредсказуемом порядке, который зависит от внешних условий. Подобная изменчивость называется недетерминизм. Его причина в том, что точное время, когда будет выполнена та или иная инструкция в программе, теперь неизвестно -- потому что нити работают независимо и не представляют, какие инструкции выполняются в других нитях.

Сам по себе недетерминизм не проблема: мы уже сталкивались с ним, когда разбирались с параллелизмом. Трудности начинаются, когда возникает наблюдаемый недетерминизм (уже упоминавшаяся ранее конкуренция, race condition).

Возьмём простой пример с нитями:

global a = 0

Thread 2:
a = 1

Thread 3:
a = 2
В результате такой работы в ячейке "a" будет либо 1 либо 2 -- но мы не можем заранее предсказать, что именно.

Однако проблемы наблюдаемого недетерминизма гораздо глубже.


# 15. Недетерминизм и время (2)
Однако проблемы наблюдаемого недетерминизма гораздо глубже. Например:

global a = 0

Thread 2:

```
I = a
a = I + 1

```

Thread 3:

```
J = a
a = J + 1
```
На первый взгляд, независимо от того, в каком порядке вызовутся нити 2 и 3, в ячейке "а" окажется значение 2, так как в каждой нити её содержимое увеличивается на 1. Однако на самом деле в ячейке "а" вполне может оказаться 1 (и на практике скорее всего так и будет).

Причина в том, что в реальных условиях работа нитей чередуется, причём в общем случае невозможно понять, как. Исходный код программы транслируется в двоичный машинный код, и механизм обеспечения одновременного выполнения нитей выделяет так называемый квант времени поочерёдно каждой нити. За этот квант времени может, например, выполниться всего одна машинная инструкция, то есть явную привязку квантованного выполнения к исходному коду выполнить фактически невозможно.

# 15. Недетерминизм и время (3)

Но даже если мы будем условно считать, что за один квант выполняется одна инструкция исходного кода, ситуация не проясняется. Вполне вероятен например такой порядок одновременного выполнения нитей 2 и 3:

```
a = 0
I = a # I = 0
J = a # J = 0
a = I + 1 # a = 1
a = J + 1 # a = 1
```

Это самый простой пример, а в реальных программах, где смешиваются параллельные вычисления и состояния, постоянно возникают значительно более сложные конфликтные ситуации. Мастерство разработки подобных программ в очень существенной степени связано с пониманием принципов "чередования" работы нитей, квантованного выполнения кода.

Печально известный пример -- канадский аппарат лучевой терапии Therac-25, который из-за подобного бага выдавал пациентам дозы, в тысячи раз превышающие назначенные, что приводило к смертям и тяжёлым заболеваниям. Одна и та же переменная в этом аппарате использовалась сразу в двух задачах, которые могли выполняться одновременно.

Отсюда важный вывод: старайтесь никогда не использовать вместе параллелизм и состояния. Программу практически всегда можно спроектировать так, чтобы разделить эти аспекты, или, в самом крайнем случае, ограниченно и наглядно совместить их в совсем небольшой и хорошо изолированной части проекта.

# 15. Недетерминизм и время (4)

В общем случае под недетерминированным алгоритмом понимают алгоритм, который при одних и тех же данных возвращает разный результат. Классический пример таких алгоритмов -- вычисление, "угадывающее" результат.

Например, алгоритм вычисления квадратного корня из N может генерировать случайное число, умножать его на само себя, и проверять, будет ли результат близок к N. Понятно, что при однократном испытании такой алгоритм скорее всего не выдаст верный результат, однако если его вызывать много-много раз, в конце концов (возможно, через тысячелетия работы компьютера) мы получим нужный результат.

Другой пример -- поиск индекса нужного значения в массиве. Алгоритм выбирает случайный индекс в массиве, и проверяет, равен ли элемент массива по этому индексу нужному значению.

Такие алгоритмы напрашиваются для реализации в параллельном формате. Вместо того, чтобы ждать тысячу лет, можно собрать компьютер со ста тысячами ядер, запустить на каждом отдельный процесс, и получить результат за один час.

Но особенность недетерминированных алгоритмов в том, что в общем случае они не укладываются в полиномиальное время -- сложность их выше, чем O(n^x), а например, O(2^n).