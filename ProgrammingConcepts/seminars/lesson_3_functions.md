# 3.1. Функции
Если мы хотим вычислить факториал 10! , можно записать такое выражение:

println(1*2*3*4*5*6*7*8*9*10)
Но если мы хотим посчитать 100! , вручную вводить все множители неудобно. В общем случае хотелось бы иметь возможность считать факториал любого целого неотрицательного числа n. Для этого определим функцию с именем fact, которая будет получать параметром значение n.

Функции в Julia определяются так:

```
function имя ( список параметров через запятую )

  тело функции

end
```
Каждый параметр -- это локальная переменная, которая видна только в пределах тела функции. Каждый раз при вызове функции параметры внутри неё создаются заново с нуля.

Результат, который функция возвращает -- это значение её последнего выражения перед end. В общем случае можно использовать оператор return в любом месте тела функции, и для наглядности рекомендуется использовать return.

Тело функции задаётся с отступами (как в языке Python); рекомендовано делать четыре пробела и не использовать в отступах TAB.

```
function fact(n)
    if n <= 0
        return 1
    else
        return n * fact(n-1)
    end
end

println(fact(10)) # 3628800

```

# 3.2. Условия
Тело функции fact() состоит из одного условного оператора с двумя ветками.

Синтаксис условного оператора в Julia:

``` 
if выражение-1 

  ветка-1

elseif выражение-2 

  ветка-2

...

else

  ветка-n

end 
```
Разделы elseif и else можно опускать. Начальный if и конечный end обязательны. Соответствующая ветка выполнится, если истинно относящееся к ней условие. Ветки располагаются внутри if с отступами.

# 3.3. Рекурсия
Функция fact работает так: если условие n <= 0 истинно, вычислится значение "выражения" 1, и return вернёт его в качестве результата работы fact.

Если условие n <= 0 ложно (значение параметра n больше нуля), выполнится ветка else -- вычислится выражение n * fact(n-1). Такой вызов в теле функции её же самой называется рекурсия.

В данном случае вызов n * fact(n-1) раскрутится в n * (n-1) * fact(n-2), и так далее до тех пор, пока n не станет равным 0. Тогда функция в конце такой цепочки вызовов вернёт 1, которое затем будет умножено на 2, и обратно до исходного n.

# 3.4. Приведение типов
Вызывав fact(20), мы получим 2432902008176640000, но вызывав fact(50), получим -3258495067890909184. Мы проходили проблему с переполнением значений переменных на базовом курсе. Напомню, проблема в том, что, в зависимости от используемой вами версии Julia и операционной системы, для хранения целого числа скорее всего отведено 64 разряда, и слишком большие числа представляются некорректно.

В Julia поддерживается большой набор базовых целых и вещественных типов, для которых указывается разрядность: Int8, Int64, Int128, Float32, Float64 и т. д. Существуют также типы BigInt с BigFloat с произвольной точностью, но операции с ними эмулируются программно, поэтому увлекаться ими не стоит, если актуальны вопросы производительности.

Приведение некоторого значения V к типу T в Julia записывается так:

T(V)
Если мы хотим, чтобы функция fact() вернула значение типа BigInt, ей надо явно указать, что она получает аргумент этого типа (например, с помощью приведения типа), тогда и все результирующие вычисления с ним будут автоматически приведены к BigInt.

```
fact(50) # -3258495067890909184
fact(BigInt(50)) # 30414093201713378043612608166064768844377641568960512000000000000
```

# 3.5. Функциональная абстракция
Задействуем функцию факториала для определения количества сочетаний из n по r.

```
function comb(n, r)
    div(fact(n), fact(r)*fact(n-r))
end
```
В comb() функция fact() вызывается три раза. Такой принцип, когда в определении новых функций используются готовые внешние функции, называется функциональная абстракция. Если таким способом строить большие программы, они становятся похожими на луковицы со многими слоями: функции, вызывающие функции, вызывающие функции...

В Julia допускается компактная запись определений коротких функций, которые умещаются в одной строке:

имя-функции(список-параметров) = тело функции
Например:

```
comb(n, r) = div(fact(n), fact(r)*fact(n-r)) 

println(comb(10,3)) # 120
```

# 3. Функции (задания)
Синтаксис параметров функции (args...) допускает переменное количество аргументов.

Имеется следующее определение функции с переменным количеством агрументов:

function varargs(args...)
    return args
end