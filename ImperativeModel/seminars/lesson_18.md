# 18. Пример выбора между stateful-моделью с состояниями и декларативной stateless-моделью
Рассмотрим пример создания генератора случайных чисел. Этой теме посвящено огромное количество работ, в частности, глубокое погружение в тему имеется в "Искусстве программирования" Кнута.

На практике применяются три основных подхода к созданию таких генераторов.

1. Использование неких непредсказуемых событий на уровне ОС -- например, связанных с параллелизмом. Увы, такая непредсказуемость не подчиняется простым законам. Например, использование планировщика потоков в качестве источника случайности даёт некоторые случайные "колебания", однако они не характеризуются качественным распределением вероятности. Более того, они тесно связаны с вычислениями столь неочевидными способами, что даже если бы их распределение было подходящим, оно всё равно зависело бы от вычислений. Таким образом, это не лучший источник случайных чисел.

2. Использование готового источника истинной случайности. Например, электронные схемы генерируют шум, который представляет собой практически непредсказуемый сигнал, приблизительное распределение вероятности которого известно. Фактически, для всех практических целей он действительно случаен. Но есть две проблемы.

Во-первых, само по себе распределение вероятности точно не известно: оно может слегка меняться от одной схемы к другой, или в зависимости от температуры окружающей среды. Да, есть способы "нормализовать" случайные числа так, чтобы их распределение стало известным. Но существует вторая, более серьезная проблема: случайность нельзя воспроизвести иначе, нежели просто сохранив серию случайных чисел от источника, и воспроизведя их в коде.

Но требование повторной воспроизводимости некоторой случайной последовательности в программировании возникает постоянно -- например, при отладке некоторого симулятора или игры. Мы хотели бы варьировать некоторый параметр генератора так, чтобы каждый раз получать разные, но повторяемые для конкретного значения параметра последовательности. По этой причине в обычных компьютерах обычно не используются действительно случайные генераторы.


Генератор равномерно распределённых случайных чисел
Генератор случайных чисел хранит внутреннее состояние, с помощью которого он вычисляет следующее случайное число и следующее внутреннее состояние. Состояние должно быть достаточно большим, чтобы обеспечить длительный период повторения. Генератор инициализируется значением, называемым "зёрнышко" (seed). Повторная инициализация с тем же самым зёрнышком должна дать ту же самую последовательность случайных чисел. Если нам не нужна одна и та же последовательность, мы можем инициализировать генератор информацией, которая никогда не будет одинаковой -- например, текущей датой/времем в секундах (или их долях), начиная с некоторой точки отсчёта. Во всех современных ОС есть операция для получения такой информацию о времени.

Определим абстрактный тип данных для генератора псевдослучайных чисел.

Конструктор с параметром Max создаёт экземпляр генератора с внутренним состоянием. Max задаёт максимальное значение случайных чисел, если явных требований к верхней границе нету, лучше выбирать его побольше.

Метод Init с параметром Seed инициализирует генератор заданным зёрнышком, которое располагается в диапазоне 0,1,...,Max. Отсюда понятно, что Max желательно выбирать достаточно большим, чтобы избегать повторяющихся последовательностей. Init может быть вызван в любой момент.

Метод Rand возвращает случайное число и обновляет внутреннее состояние. Число генерируется в диапазоне 0,1,...,Max-1. Все числа в этом диапазоне имеют равную вероятность генерации.


Как вычислить очередное случайное число? Например, популярный и простой -- так называемый линейный конгруэнтный метод, где

X(i) = (a * X(i-1) + c) % m.
Возможный набор констант: m = 10 (все числа получаются в диапазоне 0..9), X(0) = a = c = 7, последовательность формируется такая: 7,6,9,0,7,6,9,0,...

Период в такой последовательности не превышает m.

Внутреннее состояние -- это X(i).

Более реалистичные значения: a = 333667, c = 213453321, m = 1000000000.

В виде АТД данный алгоритм в stateful-модели реализуется просто и прозрачно. Однако если вы попытаетесь реализовать данный алгоритм в виде обычной функции, то сразу возникнет вопрос, где хранить её промежуточное состояние? В языках типа Си это решалось добавлением глобальной переменной внутри модуля стандартной библиотеки, где располагалась соответствующая функция, но этот подход нарушает сразу несколько принципов хорошего стиля разработки. Поэтому в современных языках в качестве генераторов случайных значений используется не функция, а объект (например, в C# это класс Random).

Однако линейный конгруэнтный алгоритм может быть реализован и без состояния, в декларативной модели -- как ленивая функция или итератор. Например, в Python такой генератор без внутреннего состояния легко программируется с помощью yield.

## Общие выводы

И модель с состояниями, и декларативная модель в целом смотрятся одинаково разумными для прикладного использования.

Качественное проектирование АТД или выбор готовой структуры данных в реализации некоторого компонента существенно важнее, нежели выбор вычислительной модели (stateful, stateless, ...).

Декларативные программы обычно менее читабельны, нежели программы с состояниями, потому что они должны быть написаны, как правило, в конвейерном виде (данные передаются между функциями).

Программы с состояниями обычно получаются более монолитными, нежели декларативные, потому что явное состояние может модифицироваться достаточно свободно. Для борьбы с излишней монолитностью применяются например соответствующие подходы ОО-проектирования.

Существенно легче распараллеливать декларативный код, потому что между его частями существенно меньше зависимостей, нежели в случае stateful-модели.