# Декларативная модель с явным состоянием
Явное состояние -- это пара из двух сущностей языка программирования. Первая сущность -- это идентичность (identity) состояния, способ его именования в программе, а второе -- текущее содержание состояния (значение, с которым связано имя, идентичность состояния). И существует операция, которая позволяет через идентичность состояния получить текущее содержимое состояния.

## 7. Ячейка
Мы добавляем новый базовый тип в вычислительную модель -- явное состояние, и называем его ячейка.

Ячейка состоит из неизменяемого имени и связанной с ним ссылки на объект в хранилище однократных присваиваний. Так как имя ячейки менять не допускается, все ячейки получаются чистыми АТД. Множество всех ячеек располагается в мутабельном хранилище.

Итоговая вычислительная модель состоит из иммутабельного хранилища однократных присваиваний, которое хранит dataflow-переменные (которые могут быть связаны только с одним значением), и из мутабельного хранилища, которое хранит пары из имён и ссылок. В этой вычислительной модели существует простой язык программирования, который расширяет декларативную модель всего двумя операциями: NewCell и Exchange.

NewCell имеет два параметра C и X и создаёт новую ячейку с именем C и содержимым X.

Exchange имеет три параметра C, X и Y, связывает X с прежним (текущим) содержимым ячейки C, и задаёт этой ячейке новое содержимое Y.

Для большей выразительности в терминах этих операций в модель добавляются ещё две инструкции.

Операция @ организует доступ к содержимому ячейки C:
```
X = @C
```
Операция := присваивает ячейке C новое значение Y, и возвращает старое значение ячейки X:
```
C := Y
```
Удивительно, но добавления ячейки с двумя операциями (фактически, классические запись значения и считывание значения) достаточно, чтобы построить все замечательные концепции, которые может предоставить понятие состояния!
Все сложные концепции объектов, классов и других абстрактных типов данных могут быть построены с помощью декларативной модели, дополненной ячейками.

Это семантика, но и языки обычно имеют синтаксическую поддержку этих концепций, чтобы они стали простыми в использовании, а реализация обеспечивает их эффективность.

# Связь с декларативным программированием

Вообще говоря, stateful-программа не может считаться декларативной, так как её прогон несколько раз с одними и теми же входами может давать разные выходы в зависимости от её внутреннего состояния. Можно, однако, писать stateful-программы так, что они будут вести себя как если они декларативные -- т.е. писать их так, чтобы они удовлетворяли определению декларативной операции. Это сам по себе хороший принцип проектирования: писать stateful-компоненты так, чтобы они вели себя декларативно.

Можно взять любую функцию из предыдущего курса, например Filter(), и переписать её в императивном виде, без рекурсии: просто одним циклом перебрать все элементы списка, и если очередной элемент отвечает требованиям функции-предиката, добавляем его в список-результат. Этот список-результат -- локальная переменная внутри Filter, явное состояние, однако с точки зрения пользователя функция Filter осталась декларативной: она не меняет значения аргументов и не создаёт никаких других побочных эффектов. Мы просто сменили декларативную реализацию декларативной функции Filter на императивную, оставив её "интерфейс" (сигнатуру) неизменным.

Ещё одна полезная вещь, связанная с состоянием и декларативной моделью -- это мемоизация, когда функция запоминает результаты предыдущих вызовов (если они например требовали больших объёмов вычислений), и при повторных вызовах с теми же параметрами выдаёт результат молниеносно. Такая функция где-то внутри работает с состояниями (замыканием), однако формально остаётся декларативной.

# Совместное использование (sharing)

При работе с состояниями возникает ряд тонких моментов, которые обязательно подлежат формализации. Это, прежде всего, понятие равенства ячеек. Можно ли считать, что две ячейки равны, если равно их содержание? А если два идентификатора X и Y ссылаются на одну и ту же ячейку? Такой случай называется совместное использование (sharing) или альясинг (aliasing), а подобные идентификаторы называют алиасы (термин, активно использующися в ИТ). Изменение содержимого X автоматически влечёт изменение содержимого Y, так как их содержимое на самом деле физически одно. Этот момент в ООП называется передача объекта по ссылке.

Когда алиасов ячейки много, понимание программы сразу существенно усложняется. Решается данная проблема инкапсуляцией состояния -- выделением всей логики работы с состоянием в небольшую и чётко определённую часть программы и определёнными гарантиями, что оно не сможет оттуда выбраться. Это одна из ключевых причин, по которой абстрактные типы данных -- особенно хорошая идея при использовании явных состояний, которые инкапсулируются в АТД и скрываются за набором корректных высокоуровневых операций.

# Как сравнивать значения ячеек?

Два значения в декларативной модели считаются равными, если они структурно эквивалентны, и значения всех полей в их структуре все равны друг другу:
```
X = person(age:25, name:"Petya")
Y = person(age:25, name:"Petya")
```
Значение X будет равно значению Y.
Однако в случае ячеек ситуация будет другая. Например, код
```
NewCell(X, 10)
NewCell(Y, 10)
```
создаёт две ячейки X и Y, каждая из которых хранит значение 10 (X и Y не алиасы), однако ячейки X и Y считаются не равны друг другу.

Схема проверки равенства ячеек называется эквивалентность токенов.

Равенство (эквивалентность) ячеек подразумевает, что при изменении содержимого одной ячейки изменится и содержимое другой ячейки -- фактически, "равные" ячейки просто должны быть алиасами.

Конечно, проверка равенства содержимого неэквивалентных ячеек вполне возможна:
```
@X == @Y
```
Но в целом, это просто совпадение; такое равенство очевидно не обязательно должно оставаться верным на протяжении работы всей программы, так как содержимое ячеек может меняться.

