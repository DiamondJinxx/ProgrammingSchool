# Абстрактные типы данных (АТД)
Мы изучали абстрактный тип данных в декларативной модели -- это набор значений вместе с набором операций над этими значениями. Теперь мы добавим в АТД понятие состояния.

## 8. 8 способов организации АТД
АТД с одинаковой функциональностью "внутри" могут быть организованы (реализованы) по-разному. Например, ранее мы изучали, как сделать АТД защищённым. Теперь введём ещё две оси -- состояние и бандлинг (bundling; упаковка, связывание, комплектация), каждая из которых предлагает два варианта. Эти три оси ортогональны, и в общей сложности получается восемь способов для организации АТД. Одни из них используются редко, другие распространены, но у каждого свои преимущества и недостатки.

## 1) Открытость и защищённость
Открытый АТД -- это такой АТД, внутреннее представление которого полностью видимо во всей программе. Реализация может быть распределена по всему коду, и различные её части могут расширять реализацию независимо друг от друга. Это полезно для небольших проектов, когда выразительность значительно важнее, нежели безопасность.

Защищенный (безопасный) АТД -- это такой АТД, реализация которого сосредоточена в одной части программы, и недоступна остальным частям. Обычно так желательно или требуется в больших проектах, потому что такой подход позволяет реализовать и тестировать АТД независимо. Возможно, вы удивитесь, но безопасный ADT может быть полностью определён в декларативной модели, используя принципы программирования высшего порядка. Никаких дополнительных концепций (например, имён и видимости) не требуется.

АТД может быть частично безопасным -- например, права на просмотр его внутренней реализации могут быть выданы контролируемым образом, как мы реализовывали функции Wrap и Unwrap для реализации стеков.

## 2) Состояние
Stateless-АТД (или декларативный АТД) создаётся в декларативной модели. Декларативные экземпляры АТД модифицировать не разрешается: надо создавать новые сущности. Поэтому, когда процедуре передаётся экземпляр АТД, всегда можно быть уверенным, что это значение уникальное -- после своего создания экземпляр АТД никогда не изменяется. С другой стороны, такой подход приводит к увеличению количества экземпляров в программе, которыми со временем становится трудно управлять. Код также получается менее модульным, поскольку экземпляры должны явно передаваться по конвейеру даже через те части, которые могут и не нуждаться в экземпляре АТД.

Stateful-АТД внутри использует явное состояние. При таком подходе экземпляры АТД могут изменяться с течением времени. При этом нельзя быть уверенным, какое именно значение инкапсулировано внутри экземпляра, не зная истории всех вызовов процедур с момента его создания.

В отличие от декларативных АТД, в данном случае существует только один физический экземпляр. Более того, этот единственный экземпляр часто даже не нужно передавать в функции в качестве параметра; доступ к нему можно получить с помощью лексического замыкания. Такой подход делает программу более лаконичной. Программа также становится потенциально более модульной, поскольку части, которым не нужен экземпляр, можно не упоминать.

## 3) Бандлинг

Наряду с безопасностью и состоянием, третий выбор, который необходимо сделать, заключается в том, будут ли данные храниться отдельно от операций (распаковка, unbundled), или же будут храниться вместе (bundled). Конечно, распакованный АТД всегда можно запаковать тривиальным способом, поместив данные и операции в одно целое. Но запакованный АТД практически не может быть распакован; семантика гарантирует, что он всегда остается запакованным. Конечно, всегда можно выполнить технический рефакторинг проекта, тут речь о формальном подходе к распаковке.

Распакованный АТД -- это АТД, для которого можно отделить данные от операций. Замечательный факт, что распакованный АТД может быть безопасным. Для этого каждый экземпляр создается вместе с "ключом". Ключ -- это разрешение на доступ к внутренним данным экземпляра (и обновление их, если экземпляр имеет состояние). Все операции АТД знают ключ, но остальная часть программы не имеет к ключу доступа. Обычно ключ - это имя (неизменяемая константа).

Распакованный АТД может быть более эффективным, чем запакованный. Например, в файле можно хранить наборы значений, каждое из которых будет соответствовать своему экземпляру АТД. Запакованный АТД подразумевает, что требуется хранить вместе и код и операции таким образом, что они не могут быть разделены программистом. Пример -- ООП, когда в памяти каждый объект хранится как набор данных и операций их обработки (методов). На практике, конечно, один и тот же код методов целиком в каждом объекте физически обычно не хранится, достаточно иметь лишь ссылку на код, и тем не менее сам подход создаёт ощутимые сложности.


# Практические способы организации АТД
На практике из восьми комбинаций способа организации АТД обычно используются следующие (по мере усложнения):

- Открытый, декларативный, распакованный. Этот подход реализован например в языках Scheme и Prolog.
- Защищённый, декларативный, распакованный. Добавляем "обёртки" для реализации безопасного декларативного стиля.
- Защищённый, декларативный, запакованный. Получаем объектно-ориентированное расширение декларативного стиля.
- Защищённый, stateful, запакованный. Классический ООП, как в Smalltalk или Java.
- Защищённый, stateful, распакованный. Распакованный вариант ООП.

Первые два пункта мы рассматривали на предыдущем курсе:
- NewStack() – создать новый стек;
- Push(Stack s, T elem) – втолкнуть элемент elem в стек s;
- Pop(Stack s) – вытолкнуть элемент из стека s;
- T Peek(Stack s) – получить верхний элемент стека s, не меняя сам стек;
- IsEmpty(Stack s) – булева проверка, пустой ли стек s.

Первые три функции возвращают в качестве своего значения новый стек, так как все функции чистые и не меняют значений своих аргументов.

# Защищённая декларативная распакованная версия с обёртками
- NewStack() возвращает Wrap( [ ] ).
- Peek(Stack s) и IsEmpty(Stack s) делают предварительно внутри Unwrap(s).
- Push(Stack s, T elem) и Pop(Stack s) после Unwrap(s) модифицируют результат и затем выполняют Wrap() для нового списка, который и возвращает.

# Защищённая декларативная запакованная версия
Идея -- спрятать стек внутри операций с помощью лексического замыкания, так что он не может быть от них отделён. Синтаксис становится похожим на ООП:

```
S1 = NewStack()
S1.IsEmpty()
S2 = S1.Push(23)
S3 = S2.Pop(X)
S4 = S3.Pop(Y).Push(256).Push(-1)
```
Мы придерживаемся декларативной модели, каждый "метод" по-прежнему возвращает новый стек, не меняя текущий. Так как эта версия запакована, обёртки Wrap/Unwrap вызывать не нужно: мы получаем в качестве результата не "физический" стек, а некий "объект", заглянуть внутрь которого невозможно. Для обеспечения безопасности такого АТД не требуется явного состояния, достаточно только программирование высшего порядка.

Поскольку эта версия является одновременно запакованной и безопасной, мы можем рассматривать ее как декларативную форму объектно-ориентированного программирования. По сути, мы получили декларативный объект.

# Защищённые stateful-версии
Защищённый, stateful, запакованный стек реализуется классическим подходом ООП + АТД. Есть объект, содержащий внутреннее поле (сам стек в некотором внутреннем представлении, например связный список), которое инкапсулировано, и есть методы доступа к нему и его модификации.

Защищённый, stateful, распакованный стек на практике применяется редко в ООП и ФП, хотя и незаслуженно. Он не требует программирования высшего порядка. Каждая операция требует один параметр (стек) и не создаёт новый объект, модифицируя аргумент. Только операция NewStack требует вызова Wrap, все остальные операции используют лишь Unwrap для доступа к внутреннему представлению стека.

```
S1 = NewStack()
IsEmpty(S1)
Push(S1, 23)
X = Pop(S1)
```