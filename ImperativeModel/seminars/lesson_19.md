# 19. Управление ресурсами
Сборка мусора -- классическая техника автоматического управления памятью и освобождения её от неиспользуемых сущностей. Однако она может плохо работать, если эти сущности не входят в используемую вычислительную модель -- например, они просто взаимодействуют с нашей системой из внешнего мира, и при этом могут "ломаться" (например, становиться недоступными, отключаться по таймауту и т. д.).

Тут возможны два подхода:

1. Внутри вычислительной модели хранится ссылка на внешнюю сущность -- назовём её указатель на ресурс. Например, это:
- дескриптор файла ОС, через который мы закрываем файл, обработка которого завершена;
- сущность, связывающая приложение с СУБД, через которую мы закрываем соединение с базой данных;
- указатель на блок памяти, выделенный ОС -- когда работа с ним завершена, мы явно освобождаем память.

2. Внутри вычислительной модели хранится ссылка, полученная из внешнего мира -- она называется ярлык (ticket). Ярлыки применяются в распределённом программировании для связывания процессов вместе. В общем случае в этом подходе нету безопасного способа для освобождения памяти или другого ресурса по окончании его использования. Один из приёмов -- механизм временной аренды (time-lease mechanism) внутри применяемого языка программирования, который предполагает доступ к таким внешним сущностям на ограниченный период времени, после чего этот доступ надо обновлять (получать новый ярлык). В таком случае приложение сразу проектируется с учётом того, что время "аренды" внешнего ресурса может истечь.

Первый подход в языках программирования нередко поддерживается так называемой финализацией -- возможностью выполнить определённые инструкции, когда соответствующая сущность перестала быть доступной (например, файл был закрыт). Обычно это явно реализуется в коде дополнительной инструкцией (например, finalize), закрывающей блок, который начинается командой открытия файла. За finalize соответственно следует код, который обязательно вызовется, когда обработка файла полностью завершится.

С помощью однократного вызова финализации, например, можно реализовать ленивую обработку файла. Имеется компонент с внутренним состоянием (например, функция с замыканием), который представляет собой своеобразный итератор по содержимому файла. Он хранит внутри дескриптор файла, и при очередном обращении к такому итератору файл открывается, если ещё не был открыт, из него считывается очередной блок данных (текущая позиция в файле также сохраняется во внутреннем состоянии), и так продолжается, пока файл не будет считан полностью. А когда он закончится, однократно вызывается финализация, которая закрывает файл и выдаёт нужное сообщение о завершении работы.

