# Общие принципы построения GUI

Наверное, любой программист, создававший графические пользовательские интерфейсы, сталкивался при этом с существенными сложностями. Когда надо спроектировать форму с большим количеством компонентов, логика взаимодействия которых достаточно сложна, код быстро запутывается. А ведь эту самостоятельную "клиентскую" логику надо ещё увязать с основной логикой программы...

По материалам учебника Concepts, Techniques, and Models of Computer Programming и других работ автора Peter Van Roy
(Universite catholique de Louvain, Swedish Institute of Computer Science).

# Общие принципы построения GUI

В ИТ практикуются три основных подхода к построению GUI, каждый из которых имеет свои весьма серьёзные недостатки:

-- Командный стиль. GUI формируется последовательностями графических команд (установить курсор в позицию, нарисовать кнопку, изменить внешний вид элемента, ...). Как правильно, тут применяется функциональная или объектно-ориентированная парадигма, потому что такие команды удобно комбинировать и структурировать. Этот подход достаточно выразительный, и вдобавок, позволяет менять GUI на лету во время работы программы -- но он сложный.

-- Декларативный стиль. GUI конструируется из набора предопределённых возможностей. Типичный пример -- это HTML/CSS. Этот подход, наоборот, лёгкий для использования, однако ему существенно не хватает выразительности.

-- Визуальный редактор. GUI "рисуется" мышкой в визуальном конструкторе форм, как например в Microsoft Visual Studio. Такой подход отличается высокой простотой, и вдобавок даёт немедленную обратную связь о внешнем виде проектируемой формы, но сильно страдает в плане выразительности кода для программиста, и не позволяет (или позволяет, но трудно) менять интерфейс во время работы программы. Компромиссный подход принят в Visual Studio, где физически сама форма хранится в декларативном описании, в формате XAML, основанном на XML.

Однако ни один из этих подходов нельзя считать достаточно хорошим, и главная причина в том, что каждый подход ограничен единственной вычислительной моделью.

Мы рассмотрим, как, комбинируя сразу несколько парадигм, создать прикладной инструмент для построения GUI, который предоставлял бы пользователю высокий уровень абстракции, вдобавок позволяя автоматически генерировать пользовательские интерфейсы. Для этого будем постепенно расширять декларативный подход другими парадигмами.

Декларативный подход как одна крайность подразумевает статические описания GUI, которые некоторая исполнительная система автоматически преобразует в пользовательский интерфейс.

Функциональный подход как другая крайность подразумевает "вычисление" GUI с помощью команд некоего языка программирования графических задач.

Это так называемая классическая проблема останова, неразрешимость которой доказана Аланом Тьюрингом. Чем более выразителен некий вычислительный язык, тем сложнее подвергать программы на нём каким-то формальным манипуляциям. Например, даже начинающий программист может написать код, генерирующий и анализирующий HTML-файлы, однако куда труднее сделать это по отношению к программе, состоящей из графических команд. Это глубинное свойство вычислительных моделей, которое нельзя разрешить инженерными, изобретательскими приёмами. Тут надо скомбинировать несколько парадигм так, чтобы система получилась одновременно и выразительной, и простой, и гибкой, и в то же время удобно подверженной формальной обработке.

Функциональный подход будем использовать там, где важна прежде всего выразительность, а декларативный -- где требуется удобная обработка, модификация внешнего вида GUI. Поэтому надо объединить декларативный фундамент с процедурными концепциями (включая объекты и нити), и получить концепт практического инструмента для проектирования GUI, который даёт пользователю высокий уровень абстракции.

Декларативный подход задаёт базовый набор возможностей UI с различными атрибутами. Разработчик выбирает подходящее из этого набора, и определяет структуру данных, которая описывает интерфейс. Чисто декларативный подход позволяет легко и формально манипулировать определениями пользовательского интерфейса. Однако выразительность в целом будет ограничена, поскольку на этом уровне можно выразить только то, что проектировщик думал про UI "изначально", в статике.

Процедурный подход даёт набор примитивных операций и возможность писать с их использованием программы, конструирующие интерфейс (своеобразное метапрограммирование, столь любимое Аланом Кэем). Чисто процедурный подход не имеет ограничений по выразительности, поскольку в своем общем виде он определяет полноценный язык программирования прикладной области (DSL). Однако это затрудняет формальные манипуляции с программными "определениями" пользовательского интерфейса, вычисляющими UI.

Этот компромисс -- глубинное свойство вычислительных моделей. По мере того, как язык становится более выразительным, его программы становятся менее поддающимися формальному манипулированию (например, автоматической кодогенерации). Однако этот компромисс не так плох, как кажется на первый взгляд. Всё ещё можно определить модель, которая будет одновременно и выразительной, и неплохо подверженной формальным манипуляциям. Мы можем сделать это, сочетая декларативный и процедурный подходы. Декларативный -- в тех областях, где важна манипулируемость, но достаточно ограниченной выразительности. Процедурный -- в тех областях, где выразительность очень важна.

Базовый элемент GUI -- это окно. Ему будут присущи четыре декларативные характеристики:

1. Статическая структура окна как множество вложенных виджетов, где виджет -- это некоторый простейший, примитивный компонент GUI;
2. Типы виджетов;
3. Начальное состояние виджетов;
4. Поведение окна при изменении размеров (как виджеты будут менять свою позицию и размеры, когда меняется размер окна).

В нашей системе будут также две процедурные части:

1. Функции, которые выполняются при возникновении внешних событий -- они будут называться actions (чтобы не путать с обычными действиями). Внешние события -- это некие "происшествия" в системе, которые обнаруживаются окном.
2. Объекты, которые могут быть призваны для изменения интерфейса различными способами. Такие объекты будут называться handlers (обработчики).

Таким образом мы получаем полное формальное определение GUI: некоторая (вложенная) запись (набор значений) с встроенными в неё actions и обработчиками. Так как это запись, то можно формально манипулировать всеми её декларативными элементами. Так как это функции и объекты, с их помощью можно выполнять любые вычисления.

Каждый виджет специфицируется своей записью (которая передаётся по значению). Если в конкретном языке записи не поддерживаются, можно использовать обычные объекты только с полями, без методов, и с операцией клонирования/копирования. В принципе, не обязательно создавать специальный графический мини-язык, достаточно стандартных возможностей практически любого языка по работе с записями и массивами/списками.

Начинать построение конкретного GUI рекомендуется с декларативной формы, и добавлять функциональный подход там, где требуется выразительность. В некотором смысле данный подход напоминает конструирование веб-интерфейса с помощью декларативного HTML/CSS с последующим добавлением "динамики" с помощью языка программирования JavaScript. Минус классического веб-подхода, что он слишком "тяжёл", мало выразителен.

Модель GUI состоит из пяти элементов:

Окно -- это прямоугольная область на экране, содержащая набор виджетов, упорядоченных по некоторой раскладке.

Виджет -- это элементарный компонент GUI, который визуально представляется на экране и поддерживает некоторый протокол взаимодействия с пользователем. Виджет задаётся записью, которая содержит тип, начальное состояние, ссылку на обработчик и набор actions, которые виджет может вызвать. Протокол взаимодействия определяет, какая информация показывается в виджете, и какие последовательности пользовательских действий и actions виджета допустимы.

Событие -- хорошо определённое дискретное воздействие из внешнего мира на пользовательский интерфейс. Событие определяется своим типом, временем события и, возможно, дополнительной информацией (например, координатами мыши). События сами по себе в программе не "видны", но вызывают различные actions.

Action -- это функция, которая вызывается, когда возникает некоторое событие.

Обработчик -- это объект, с помощью которого программа может управлять виджетом. Каждый виджет содержит соответствующий обработчик.

На основе данных, которые надо отобразить, формируется описание UI. "Физически" оно представляет собой запись (логическая структура GUI), которая содержит actions (функции) и несвязанные переменные для объектов-обработчиков. Далее это описание интерпретируется для создания объектов-обработчиков и потока (нити) событий. В результате на экране появляется окно, а actions и handlers обеспечивают логику работы приложения для взаимодействия с этим окном. Обычно создаётся одна нить на окно и один объект-обработчик на виджет.

Например, простой GUI может быть описан так:

D = button(text:"Click this button")
D -- это запись, которая определяет виджет типа button (кнопка), а его содержимое задаётся атрибутом text, значение которого есть текст, показываемый на кнопке.

Некоторые типы виджетов допускают вложение других виджетов. Например, условный виджет td может включать в себя список виджетов, которые располагаются сверху вниз, а виджет lr включает виджеты, которые располагаются слева направо. Эти два виджета в некотором смысле аналог табличных тэгов HTML.

Виджет-плейсхолдер задаёт прямоугольную видимую часть окна, за пределами которой элементы будут не видны.

Что делать, кода размер родительского окна меняется? Внутренние виджеты должны само-переупорядочиться и, вероятно, изменить свои размеры. В простейшем декларативном формате каждый виджет снабжается необязательным параметром glue, который содержит произвольную комбинацию букв t, b, l и r (верх, низ, лево, право). Если присутствует только одна буква из пары tb или lr, то виджет стыкуется например вверх или вправо, сохраняя свой текущий размер, а если обе буквы, то растягивается между верхним/нижним или левым/правым виджетом/границей окна, насколько получится (возможно, с некоторым стандартным margin).

Динамическое поведение виджетов определяется их actions и обработчиками.

Action -- это часть виджета (как метод класса). Например, action может задаваться для кнопки как действие по её нажатию. Как правило, actions никаких аргументов не получают. Дополнительно actions могут связываться с внешними событиями, которые явно задаются для виджета (нажатие левой кнопки мыши или клавиши "a").

Обработчик -- это объект, который как правило контролирует пользовательскую активность и управляет внешним видом виджета (например, отслеживает ввод текста и рисует его).

Использование записей для определения UI позволяет "рассчитать" его непосредственно из исходных данных. Это мощная техника, которая поддерживает, в частности, проектирование на основе моделей. Различные аспекты дизайна GUI задаются в отдельных формализмах, называемых модели. Затем из всех моделей, взятых вместе, получается работающий графический интерфейс пользователя.

Типичные модели включают в себя модель домена, модель представления, модель диалога, модель задачи, модель пользователя, модель платформы и модель помощи. Эти модели могут быть представлены непосредственно в языке в виде структур данных, состоящих из вложенных записей и процедурных значений. Достаточно легко перевести модель домена (прикладной области) в модели представления и диалоговые модели.

Модель домена очень похожа на модель данных приложения. Она определяет объекты (типы) данных, которыми может манипулировать пользователь. Модель представления - это представление визуальных, аудио/видео и других элементов, которые UI предлагает пользователям. Диалоговая модель определяет, как модель представления взаимодействует с пользователем. Она задаёт действия, которые пользователь может инициировать с помощью элементов представления и реакций приложения.

Сегодня эта схема частично представлена популярными паттернами MVC, MVVM и подобными.