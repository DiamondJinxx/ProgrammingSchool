# Общие принципы построения GUI

Наверное, любой программист, создававший графические пользовательские интерфейсы, сталкивался при этом с существенными сложностями. Когда надо спроектировать форму с большим количеством компонентов, логика взаимодействия которых достаточно сложна, код быстро запутывается. А ведь эту самостоятельную "клиентскую" логику надо ещё увязать с основной логикой программы...

По материалам учебника Concepts, Techniques, and Models of Computer Programming и других работ автора Peter Van Roy
(Universite catholique de Louvain, Swedish Institute of Computer Science).

# Общие принципы построения GUI

В ИТ практикуются три основных подхода к построению GUI, каждый из которых имеет свои весьма серьёзные недостатки:

-- Командный стиль. GUI формируется последовательностями графических команд (установить курсор в позицию, нарисовать кнопку, изменить внешний вид элемента, ...). Как правильно, тут применяется функциональная или объектно-ориентированная парадигма, потому что такие команды удобно комбинировать и структурировать. Этот подход достаточно выразительный, и вдобавок, позволяет менять GUI на лету во время работы программы -- но он сложный.

-- Декларативный стиль. GUI конструируется из набора предопределённых возможностей. Типичный пример -- это HTML/CSS. Этот подход, наоборот, лёгкий для использования, однако ему существенно не хватает выразительности.

-- Визуальный редактор. GUI "рисуется" мышкой в визуальном конструкторе форм, как например в Microsoft Visual Studio. Такой подход отличается высокой простотой, и вдобавок даёт немедленную обратную связь о внешнем виде проектируемой формы, но сильно страдает в плане выразительности кода для программиста, и не позволяет (или позволяет, но трудно) менять интерфейс во время работы программы. Компромиссный подход принят в Visual Studio, где физически сама форма хранится в декларативном описании, в формате XAML, основанном на XML.

Однако ни один из этих подходов нельзя считать достаточно хорошим, и главная причина в том, что каждый подход ограничен единственной вычислительной моделью.

Мы рассмотрим, как, комбинируя сразу несколько парадигм, создать прикладной инструмент для построения GUI, который предоставлял бы пользователю высокий уровень абстракции, вдобавок позволяя автоматически генерировать пользовательские интерфейсы. Для этого будем постепенно расширять декларативный подход другими парадигмами.

Декларативный подход как одна крайность подразумевает статические описания GUI, которые некоторая исполнительная система автоматически преобразует в пользовательский интерфейс.

Функциональный подход как другая крайность подразумевает "вычисление" GUI с помощью команд некоего языка программирования графических задач.

Это так называемая классическая проблема останова, неразрешимость которой доказана Аланом Тьюрингом. Чем более выразителен некий вычислительный язык, тем сложнее подвергать программы на нём каким-то формальным манипуляциям. Например, даже начинающий программист может написать код, генерирующий и анализирующий HTML-файлы, однако куда труднее сделать это по отношению к программе, состоящей из графических команд. Это глубинное свойство вычислительных моделей, которое нельзя разрешить инженерными, изобретательскими приёмами. Тут надо скомбинировать несколько парадигм так, чтобы система получилась одновременно и выразительной, и простой, и гибкой, и в то же время удобно подверженной формальной обработке.

Функциональный подход будем использовать там, где важна прежде всего выразительность, а декларативный -- где требуется удобная обработка, модификация внешнего вида GUI. Поэтому надо объединить декларативный фундамент с процедурными концепциями (включая объекты и нити), и получить концепт практического инструмента для проектирования GUI, который даёт пользователю высокий уровень абстракции.

Декларативный подход задаёт базовый набор возможностей UI с различными атрибутами. Разработчик выбирает подходящее из этого набора, и определяет структуру данных, которая описывает интерфейс. Чисто декларативный подход позволяет легко и формально манипулировать определениями пользовательского интерфейса. Однако выразительность в целом будет ограничена, поскольку на этом уровне можно выразить только то, что проектировщик думал про UI "изначально", в статике.

Процедурный подход даёт набор примитивных операций и возможность писать с их использованием программы, конструирующие интерфейс (своеобразное метапрограммирование, столь любимое Аланом Кэем). Чисто процедурный подход не имеет ограничений по выразительности, поскольку в своем общем виде он определяет полноценный язык программирования прикладной области (DSL). Однако это затрудняет формальные манипуляции с программными "определениями" пользовательского интерфейса, вычисляющими UI.

Этот компромисс -- глубинное свойство вычислительных моделей. По мере того, как язык становится более выразительным, его программы становятся менее поддающимися формальному манипулированию (например, автоматической кодогенерации). Однако этот компромисс не так плох, как кажется на первый взгляд. Всё ещё можно определить модель, которая будет одновременно и выразительной, и неплохо подверженной формальным манипуляциям. Мы можем сделать это, сочетая декларативный и процедурный подходы. Декларативный -- в тех областях, где важна манипулируемость, но достаточно ограниченной выразительности. Процедурный -- в тех областях, где выразительность очень важна.

Базовый элемент GUI -- это окно. Ему будут присущи четыре декларативные характеристики:

1. Статическая структура окна как множество вложенных виджетов, где виджет -- это некоторый простейший, примитивный компонент GUI;
2. Типы виджетов;
3. Начальное состояние виджетов;
4. Поведение окна при изменении размеров (как виджеты будут менять свою позицию и размеры, когда меняется размер окна).

В нашей системе будут также две процедурные части:

1. Функции, которые выполняются при возникновении внешних событий -- они будут называться actions (чтобы не путать с обычными действиями). Внешние события -- это некие "происшествия" в системе, которые обнаруживаются окном.
2. Объекты, которые могут быть призваны для изменения интерфейса различными способами. Такие объекты будут называться handlers (обработчики).
