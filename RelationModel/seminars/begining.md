# Реляционная вычислительная модель
## Как понять в программировании всё

Реляционная модель -- это дальнейшее обобщение декларативной вычислительной модели. Процедура в декларативной модели использует свои входные аргументы для вычисления значения своих выходных аргументов. Это функциональное вычисление в математическом смысле: выходы являются функциями входов. У классической (чистой) функции для заданного множества аргументов всегда будет одно и то же единственное множество выходных значений. Выходы -- это всегда результаты вычислений функции надо входами.

Ещё более обобщим этот принцип -- сделаем его реляционным. Реляционная процедура более гибкая, нежели функциональная, в двух моментах. У реляционной "функции",
во-первых, количество результатов может быть нулевым, одним, двумя или больше, и
во-вторых, какие аргументы могут быть входами, а какие выходами, может определяться в каждом конкретном вызове по разному.

По материалам учебника Concepts, Techniques, and Models of Computer Programming и других работ автора Peter Van Roy
(Universite catholique de Louvain, Swedish Institute of Computer Science).

Именно такая гибкость и делает реляционное программирование так хорошо подходящим для применения в базах данных, а не то что дескать вся эта реляционщина была придумана исключительно для использования в СУБД. Нет, реляционное программирование гораздо шире по своему предназначению: оно активно применяется например при создании синтаксических анализаторов, и в частности, для таких сложных случаев, как дедуктивные базы данных и разбор неоднозначных грамматик (которые могут порождать строку множеством разных способов). Оно также используется в решении сложных комбинаторных задач, в искусственном интеллекте и т. п.

Реляционное программирование расширяет декларативное единственным новым типом инструкции -- "выбором". Концептуально, команда выбора недетерминированно выбирает одну из множества альтернатив (на уровне реализации выполняя поиск с перечислением возможных ответов). На практике это реализуется так называемым "недетерминизмом незнания", когда сам алгоритм выбора детерминирован, однако программист никак не может предполагать, какой конкретно выбор будет сделан.

Идея команды выбора стара: впервые она была реализована в малоизвестных языках программирования в конце 1960-х, а вот в популярнейшем языке логического программирования Пролог (1972 г.) эта команда стала фактически сердцем всей исполнительной модели.

# Осторожно, эффективность
Гибкость реляционного программирования имеет и обратную сторону -- она может легко привести к крайне неэффективным программам, если не использовать её должным образом. Потенциально роста сложности невозможно избежать, поскольку каждая новая операция выбора умножает размер пространства поиска на количество альтернатив. Пространство поиска -- это множество кандидатов на решение задачи. Соответственно получается, что его размер экспоненциально зависит от количества операций выбора.

Тем не менее, реляционное программирование имеет определённое практическое значение.

- Когда пространство поиска невелико. Обычно это характерно для баз данных, а также для ряда задач локальной оптимизации кода.

- Как инструмент исследования. Когда объём примеров небольшой, реляционное программирование может дать хорошие результаты. Преимущество реляционного подхода в том, что программы могут быть намного короче и проще в написании: не нужно придумывать алгоритм, так как поиск -- это метод грубой силы, который позволяет избежать необходимости в алгоритмах. Это, по большому счёту, пример неалгоритмического программирования.

Для применения поиска в других случаях необходимы более сложные методы -- например, мощные алгоритмы решения задач в ограничениях (у меня есть микро-курс по солверу Z3), оптимизация на основе структуры задачи, поисковые эвристики и т. п.

С точки зрения программиста, реляционная модель расширяет декларативную модель двумя новыми командами:

- choice (выбор) группирует множество альтернативных команд, выбирая при выполнении одну из них. Если выбранная альтернатива оказывается неверной, то выбирается другая.

- fail (неудача) отмечает, что текущая альтернатива неверна. fail срабатывает неявно -- в момент, когда происходит попытка связать два несовместимых значения (например, 3=4). В декларативной модели в таком случае генерируется исключение.

Реляционная программа выполняется последовательно. Операторы выбора выполняются в том порядке, в котором они встречаются во время выполнения. Когда оператор choice выполняется в первый раз, выбирается его первая альтернатива. Когда встречается оператор fail, процесс выполнения "отступает" к последнему оператору выбора, который выбирает следующую альтернативу. Если они все закончились, то происходит возврат к предпоследнему оператору choice, где берётся другая альтернатив, и так далее. Каждый choice всегда выбирает альтернативы в определённом порядке (например, слева направо).

Поиск решения в результате может быть представлен деревом поиска. Каждый узел -- команда choice, и каждое поддерево в нём соответствует одной альтернативе. В процессе поиска либо может быть найдено решение, удовлетворяющее исходным условиям, и тогда работа заканчивается, либо дерево поиска будет пройдено целиком до конца, и поиск считается неудачным. По этой базовой схеме поиска в пространстве решений работают, в частности, многие алгоритмы искусственного интеллекта.

В целом, реляционное программирование тесно связано с логическим программированием, однако активнее всего оно применяется конечно в прикладной области баз данных.

База данных -- это коллекция данных с хорошо определённой структурой. Эти данные хранятся, как правило, постоянно (например, на жёстком диске, независимо от того, запущена ли обрабатывающая их программа).

Существует много способов организации данных в БД. Один из наиболее популярных -- трактовать данные как множество отношений, где отношение -- это множество кортежей.

БД, организованная как множество отношений, называется реляционной.

На практике под отношением понимается таблица БД, а под кортежём -- запись таблицы.

Хорошо определённая структура коллекции данных -- это не просто полезная инженерная рекомендация, а вполне строгая математическая концепция. Таблица -- это n-арное отношение, которое состоит из схемы (описания структуры) и тела (данных). Поэтому реляционная база данных обязательно должна иметь свою схему (отсутствие схем обычно допускается для NoSQL-СУБД).

Например, граф может быть представлен одним отношением -- множеством кортежей, где каждый кортеж определяет одно ребро и задаётся начальной и конечной вершинами этого ребра.

Реляционная база данных хранит эти кортежи явно, так что мы можем выполнять над ними вычисления. Типичными операциями над реляционной БД считается запрос (чтение данных) и обновление (изменение данных).

-- Запрос -- это нечто большее, нежели простое чтение; это логическая формула, основными элементами которой являются отношения в базе данных. Задача СУБД -- найти все кортежи, которые удовлетворяют такой формуле.

-- Обновление означает добавление новой информации в базу данных. Эта информация должна быть правильного вида и не нарушать организацию базы данных. Обновление обычно выполняется как транзакция.

Реляционное программирование по ряду причин хорошо подходит для изучения концепций реляционных баз данных:

- оно не накладывает ограничений на логическую форму запроса. Даже если запрос сильно дизъюнктивен (подразумевает много выборов), он будет обработан правильно (хотя и медленно).

- оно позволяет экспериментировать с дедуктивными базами данных. Дедуктивная БД -- это БД, реализация которой может выводить дополнительные кортежи, которые не хранятся в явном виде. Как правило, дедуктивная база данных позволяет определять новые отношения в терминах существующих отношений. Для этих новых отношений кортежи не хранятся, но они могут использоваться так же, как и любые другие отношения.

Глубинная причина этих свойств в том, что реляционная модель вычислений -- это форма логического программирования, когда существенная часть вычислений (поиск в пространстве решений) выполняется самой системой, а не программистом, который уже не указывает подробно набором инструкций, как именно искать результат, а просто задаёт, что надо получить в итоге.

# Абстракция отношения
Определим абстракцию для выполнения вычислений над отношениями. Такая абстракция допускает три базовые операции (которые обычно поддерживаются в языках логического программирования):

-- добавить отношению кортеж;

-- добавить отношению список кортежей;

-- выполнить запрос, который свяжет частичное значение с одним из кортежей. Если условию запроса соответствует более чем один кортеж, поиск перечислит их все.

Такая абстракция может реализовываться в виде словаря, хранящего кортежи, и оператора выбора, который формирует результаты запросов.

